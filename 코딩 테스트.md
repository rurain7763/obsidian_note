#### 시간 복잡도
본래 점근적 표기법은 수학적인 개념이기 때문에 엄밀한 정의를 설명하기엔 수학적 지식이 약간 필요하지만, 우리는 간단하게 개념을 이해할 수 있는 수준으로 설명하도록 하겠습니다.
점근적 표기법에는 크게 O, Ω, Θ가 있습니다. 각각 빅-오, 빅-오메가, 빅-세타라고 부릅니다.

간단한 다항식 n3+n2+n−1이라는 식이 있다고 가정하겠습니다.

- **O는 가장 높은 차수 보다 같거나 높은 식을 뜻합니다.** 즉, n3+n2+n−1에서 가장 높은 차수는 n3 이므로 O(n3), O(n5), O(n100) 모두 맞는 말이지만, 우리는 앞으로 이 식을 보게 되었을 때 좀 tight하게 O(n3) 라고 부르게 될 것이며, 이것이 바로 시간복잡도를 재는 척도로 쓰이게 됩니다.
    
    이때 표현은 n3+n2+n−1=O(n5) 와 같이 나타낼 수 있습니다.  
    만약 f(n)=n3+n2+n−1,g(n)=n5 이었다면, f(n)=O(g(n)) 으로도 나타내 볼 수 있습니다. 이는 **f(n)의 차수가 g(n)의 차수보다 같거나 작다는 의미를 갖습니다.**
    
- **Ω는 가장 높은 차수 보다 같거나 낮은 식을 뜻합니다.**  
    즉, n3+n2+n−1에서 가장 높은 차수는 n3 이므로 Ω(n3), Ω(n), Ω(logn) 모두 맞는 말이 됩니다.
    
    만약 f(n)=n3+n2+n−1,g(n)=n 이었다면, f(n)=Ω(g(n)) 으로도 나타내 볼 수 있습니다. 이는 **f(n)의 차수가 g(n)의 차수보다 같거나 크다는 의미를 갖습니다.**
    
- **Θ는 최고차항(가장 높은 차수)을 뜻합니다.**  
    즉, n3+n2+n−1에서 가장 높은 차수는 n3 이므로 Θ(n3)이 됩니다.
    

또, 점근적 표기법은 n이 무한히 커졌을 때의 상황에 관심이 있기 때문에 **식 앞에 있는 상수값은 항상 무시합니다.** 즉, O(9n3−2)=O(n3)을 만족하며, 이 말은 즉 9n3+n2+n−1 식은 O(n3)로 나타낼 수 있음을 뜻합니다. Ω, Θ 역시 마찬가지로 상수값을 전부 무시하게 됩니다.

예시)
f(x)=x8, g(x)=x4
f(x)=O(g(x)) => x, f(x) = Ω(g(x)) => o, f(x) = Θ(g(x)) => x

n에 대한 시간 복잡도 가능 범위
- N≤10
    O(N!), O(2N), O(3N)
- N≤20
    O(2N)
- N≤100
    O(N4)
- N≤500
    O(N3)
- N≤1,000
    O(N2), O(N2logN)
- N≤100,000
    O(N), O(NlogN), O(logN), O(1)
#### 정렬
###### 버블 정렬(bubble sort)
자신과 자신 뒤의 값을 비교해가며 최종 값이 정렬된 상태가 되고 이를 반복하는 알고리즘.
###### 선택 정렬(select sort)
현재 입력 위치 뒤의 값을 모두 비교하여 적절한 값을 찾아 입력 위치에 집어 넣고 이를 반복하는 알고리즘.
###### 삽입 정렬(insert sort)
앞에 있는 모든 원소가 정렬이 되어 있다는 가정 하에서 현재 원소의 위치를 적절하게 집어넣는 정렬 알고리즘.
###### 기수 정렬(radix sort)
맨 뒤에 있는 자릿수 부터 해당 자리수를 기준으로 정렬한 뒤, 점점 앞으로 이동하며 각 자리수를 기준으로 정렬하다가 최종적으로 가장 높은 자리수를 기준으로 정렬
O(k∗n)의 시간 복잡도

수도 코드
```js
function radix_sort(arr, k)
  for pos = k - 1 ... pos >= 0:
    set arr_new = [10][]
    for i = 0 ... i < arr.size
      set digit = posth digit of arr[i]
      arr_new[digit].append(arr[i])

    set store_arr = []
    for i = 0 ... i < 10
      for j = 0 ... j < arr_new[i].size
        store_arr.append(arr_new[i][j])
  
    arr = store_arr

  return arr
```

본인 구현
```cpp
int pos = 1;
for(int i = digitCnt; i > 0; i--) {
	vector<vector<int>> newArr(10);
	for(int j = 0; j < arr.size(); j++) {
		int digit = (arr[j] / pos) % 10;
		newArr[digit].push_back(arr[j]);
	}
	int idx = 0;
	for(int j = 0; j < 10; j++) {
		for(int k = 0; k < newArr[j].size(); k++) {
			arr[idx++] = newArr[j][k];
		}
	}
	pos *= 10;
}
```

주의
자릿수가 달라도 적용 가능함. (해당 자릿수가 없는 경우에는 무조건 0번째로 취급)
###### 병합 정렬(merge sort)
O(nlogn)의 시간 복잡도

수도 코드
```cpp
function merge_sort(arr[], low, high)
  if low < high
    set mid = (low + high) / 2
    merge_sort(arr, low, mid)
    merge_sort(arr, mid+1, high)
    merge(arr, low, mid, high)


set merged_arr = []

function merge(arr[], low, mid, high)
  set i = low, j = mid + 1

  set k = low
  while i <= mid && j <= high
    if arr[i] <= arr[j]
      merged_arr[k] = arr[i]
      k += 1; i += 1
    else
      merged_arr[k] = arr[j]
      k += 1; j += 1
  
  while i <= mid
    merged_arr[k] = arr[i]
    k += 1; i += 1

  while j <= high
    merged_arr[k] = arr[j]
    k += 1; j += 1
  
  for k = low ... k <= high
    arr[k] = merged_arr[k]
  
  return arr 
```

본인 코드
```cpp
void sort(vector<int>& arr, int low, int high) {
	if(low < high) {
		int mid = (low + high) / 2;
		sort(arr, low, mid);
		sort(arr, mid + 1, high);
	
		int i = low, j = mid + 1;
		vector<int> merged;
		while(i <= mid && j <= high) {
			if(arr[i] <= arr[j]) {
				merged.push_back(arr[i++]);
			} else {
				merged.push_back(arr[j++]);
			}
		}
		while(i <= mid) {
			merged.push_back(arr[i++]);
		}
		while(j <= high) {
			merged.push_back(arr[j++]);
		}
		for(int i = low; i <= high; i++) {
			arr[i] = merged[i - low];
		}
	}
}
```
###### 퀵 정렬(quick sort)
O(nlogn)의 시간 복잡도
최악의 경우 O(n2)

수도 코드
```cpp
function partition(arr[], low, high)
  set pivot = select_pivot(arr, low, high)
  set i = low - 1
  
  for j = low ... j <= high - 1
    if arr[j] < pivot
      i += 1
      swap (arr[i], arr[j])
      
  swap (arr[i + 1], arr[high])
  return i + 1

function quick_sort(arr[], low, high)
  if low < high
    pos = partition(arr, low, high)
    
    quick_sort(arr, low, pos - 1)
    quick_sort(arr, pos + 1, high)

```

본인 코드
```cpp
int partition(vector<int>& arr, int low, int high) {
	int pivot = high;
	int i = low - 1;
	for(int j = low; j < high; j++) {
		if(arr[j] <= arr[pivot]) {
			i++;
			swap(arr[i], arr[j]);
		}
	}
	swap(arr[i + 1], arr[pivot]);
	return i + 1;
}

void sort(vector<int>& arr, int low, int high) {
	if(low < high) {
		int pos = partition(arr, low, high);
		sort(arr, low, pos - 1);
		sort(arr, pos + 1, high);
	}
}
```
###### 힙 정렬(heap sort)
###### 수도 코드
```js
// 현재 값과 자식 값을 비교하여 부모가 최대값이 아니면 재귀
function heapify(arr[], n, i)
  set largest = i
  set l = i * 2
  set r = i * 2 + 1

  if l <= n && arr[l] > arr[largest]
    largest = l

  if r <= n && arr[r] > arr[largest]
    largest = r

  if largest != i
    swap(arr[i], arr[largest])
    heapify(arr, n, largest)

function heap_sort(arr[], n)
// max-heap을 만들 때 n이 아닌 n / 2번째에서 시작하는 이유는 가장 밑에 있는 자식을 제외하고 전부 heapify를 적용하면 max-heap이 되기 때문
  for i = n / 2 ... i >= 1
    heapify(arr, n, i)

  for i = n ... i > 1
    swap(arr[1], arr[i])
    heapify(arr, i - 1, 1)
```

본인 코드
```cpp
void heapify(vector<int>& arr, int cur) {
	int mini = cur;
	int left = cur * 2;
	int right = cur * 2 + 1;

	if(left < arr.size() && arr[left] < arr[mini]) {
		mini = left;
	}
	
	if(right < arr.size() && arr[right] < arr[mini]) {
		mini = right;
	}

	if(mini != cur) {
		swap(arr[cur], arr[mini]);
		heapify(arr, mini);
	}
}

void solve(vector<int>& arr) {
	for(int i = arr.size() / 2; i >= 1; i--) {
		heapify(arr, i);
	}
	
	int sz = arr.size();
	for(int i = 1; i < sz; i++) {
		// ...
		swap(arr[1], arr[arr.size() - 1]);
		arr.pop_back();
		heapify(arr, 1);
	}
}
```
###### 안정 정렬(stable sort)
기존 순서가 유지되면서 정렬되는 알고리즘.
거품 정렬, 기수 정렬, 삽입 정렬, 병합 정렬이 그러하다.
###### in-place sort
추가적인 메모리 없이 가능한 정렬 알고리즘
거품 정렬, 선택 정렬, 삽입 정렬, 퀵 정렬, 힙 정렬이 그러하다.
#### 이진 탐색
찾아야 하는 수의 범위 중 가운데의 값과 찾고자 하는 값을 비교하여 대소관계에 따라 특정 구간으로 이동하는 것을 반복하는 것.
정렬된 상태일때 O(logN)의 시간 복잡도

비교
![img|500](https://contents.codetree.ai/problems/946/images/e013434f-ab8a-4322-bee3-656c4e017dd5.png)

정렬된 배열에서 특정 값 찾기 수도 코드
```cpp
function solution(arr, target)
  set left = 0
  set right = arr.size - 1
  while left <= right
    set mid = (left + right) / 2
    if arr[mid] == target
      return mid

    if arr[mid] > target
      right = mid - 1
    else
      left = mid + 1
      
  return -1
```
#### Lower bound/Upper bound
###### Lower bound
원하는 값이 최초로 나오는 위치 찾기

수도 코드
```js
function lower_bound(arr, target)
  set left = 0                         
  set right = arr.size - 1             
  set min_idx = arr.size               
  while left <= right                  
    set mid = (left + right) / 2       
    if arr[mid] >= target              
      right = mid - 1      
      min_idx = min(min_idx, mid)
    else
      left = mid + 1

  return min_idx
```
###### Upper bound
원하는 값이 최초로 초과하는 위치 찾기

수도 코드
```js
function upper_bound(arr, target)
  set left = 0                        
  set right = arr.size - 1             
  set min_idx = arr.size               
  while left <= right                  
    set mid = (left + right) / 2       
    if arr[mid] > target              
      right = mid - 1                  
      min_idx = min(min_idx, mid)      
    else
      left = mid + 1                  

  return min_idx                
```

![img](https://contents.codetree.ai/problems/548/images/d9c0b4e6-5b2f-4589-a1f5-4f096494633f.svg)
cf) upper bound == lower bound => 해당 값이 없다는 것을 뜻함
#### 스택
짝짖기 문제에서 자주 사용. (ex. 올바른 괄호)
함수 실행 시 콜 스택을 사용
###### 증가하는 부분 수열
전체 수열 중 일부를 골라 부분 수열을 만들었는데, 만약 그 부분 수열이 오름차순으로 증가하는 수열이라면 증가하는 부분 수열 (Increasing Subsequence) 라고 부름
{10, 30, 20, 50, 60, 15} 라는 수열이 있다면, {10, 30, 50, 60}도 증가하는 부분 수열이고, {20, 50, 60}도 마찬가지

수도 코드
```js
function solution(arr)
  set s = empty stack
  for i = 0 ... i < arr.size
    set val = arr[i]
    if s.empty() == true or val > s.top()
      s.push(val)
      print(val)
```
#### 큐
연결 리스트로 구현
###### 요새푸스
원의 끝에는 선생님이 계시고 학생이 선생님에게 가면 테스트를 받아 통과되면 집에 가고, 떨어지면 다시 줄에 서서 자기 차례가 될 때 까지 기다려야 한다고 해보자
큐에 들어간 데이터가 상황에 따라 다시 큐에 들어가야 한다면, 이 구조는 다음과 같이 원형으로 그릴 수 있다
![img|500](https://contents.codetree.ai/problems/568/images/c1961f12-3bc5-4aa4-81b6-d7e34427d152.png)

수도 코드
```js
function solution(N, K)
    set q = empty queue
    for i = 1 ... N
        q.push(i)
    while q.size() != 1
        for i = 1 ... K - 1
            q.push(q.front())
            q.pop()
        q.pop()
    return q.front()

```
#### Deque
맨 앞/뒤에서 삽입/삭제가 모두 가능함
배열과 달리 위의 메소드의 시간복잡도가 모두 O(1)
#### 재귀함수
- 정의 : 자신을 재호출하는 함수
- 사용 : 큰 문제를 작은 문제로 쪼개서 풀때
- 주의 사항
	1. 반드시 종료 조건이 있어야함.
	2. 반복문으로 풀 수 있으면 빈복문으로 풀어라.
- 예시
```C++
int factorial(int n) {
	if (n == 1 || n == 0) return 1;
	return n * factorial(n - 1);
}

int fibonachi(int n) {
	if (n == 1 || n == 0) return n;
	retrun fibonachi(n - 1) + fibonachi(n - 2);
} 
```
- 문제 해결 시 기억할 내용
	: 모든 경우를 순회해야하는 경우라면 선택한다, 안한다로 분기를 나누어준다.
	```C++
	void rec(target) {
		if(?) {
			return;
		}

		rec(next_target); // 해당 내용을 선택하는 경우 
		rec(next_target); // 해당 내용을 선택하지 않는 경우
	}
	```
#### DP
- 정의 : 기억하면서 정복하기
- 큰 문제를 작은 문제로 쪼개서 풀때 중복 연산을 제거
- 예시
```C++
int d[100];

int fibo(int x) {
	if(x == 1) return 1;
	else if(x == 2) return 1;
	else if(d[x]) return d[x];
	
	return d[x] = fibo(x - 1) + fibo(x - 2);
}

```
#### 순열과 조합
###### 순열
-  정의 :  순서와 상관있이 뽑는다.
-  알아야 할 함수 : `next_permutation(from, to)` (*오름차순 정렬*)
```C++
void permutation() {
	std::vector<int> v = {3, 2, 1}; 
	sort(v.begin(), v.end());
	do {
		for(int i : v) {
			std::cout << i << " ";
		}
		std::cout << std::endl;
	}
	while(next_permutation(v.begin(), v.end()));
}

void makePermutation(std::vector<int>& v, int c, int depth) {
    if(c == depth) {
        for(int i : v) {
            std::cout << i << " ";
        }
        std::cout << std::endl;
        return;
    }

    for(int i = depth; i < v.size(); i++) {
        std::swap(v[depth], v[i]);
        make_permutation(v, c, depth + 1);
        std::swap(v[depth], v[i]);
    }
}
```
- 공식
	${iPj}$ = $i!$ / $(i - j)!$
###### 조합
- 정의 : 순서와 상관없이 뽑는다.
- 코드
```C++
std::vector<int> combination;
void makeCombination(std::vector<int> v, int c, int start) {
    if(combination.size() == c) {
        for(int i = 0; i < combination.size(); i++) {
            std::cout << combination[i] << " ";
        }
        std::cout << std::endl;
        return;
    }
    
    for(int i = start; i < v.size(); i++) {
        combination.push_back(v[i]);
        makeCombination(v, c, i + 1);
        combination.pop_back();
    }
}
```
- 공식
	$iCj$ = $iPj$ / $j!$
###### 문자열 쪼개기
- 코드
```C++
void split(std::string str, std::vector<std::string>& vec, char delimiter) {
	size_t i;
	while((i = str.find(delimiter)) != std::string::npos) {
		vec.push_back(str.substr(0, i));
		str.erase(0, i + 1);
	}
	vec.push_back(str);
}
```
###### 중복 요소 제거
- 코드
```C++
void uniq(std::vector<int>& v) {
    std::sort(v.begin(), v.end());
    auto p = std::unique(v.begin(), v.end());
    for(auto it = v.begin(); it != p; it++) {
        std::cout << *it << " ";
    }
}
```
#### 시간 복잡도
- 정의 : 입력 값에 따른 주요 로직의 반복횟수.
```C++
void main() {
	for(int i = 0; i < n; i++) {
		for(int j = 0; j < n; j++) {
			for(int k = 0; k < n; k++) {
				//Do something...
			}
		}
	}

	// n * n * n = n^3
}
```
- 빅오 표기법
	가장 많은 영향을 끼치는 항에서 상수를 뺀 표기법.
	ex) $10n^2 + n$ == $O(n^2)$
- 기울기 비교
	![complexity_chart](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fs0pox%2Fbtq6Mbphdwr%2Fs5K0D58hi5hiSrBuxmHHwk%2Fimg.png)
- 코드
```C++
int main() {
    int n;
    std::cin >> n;

    int execCount = 0;
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < i; j++) {
            execCount++;
        }
    }

    std::cout << execCount << std::endl;

	// 1/2 * (n^2 - n)
}
```
###### 공간 복잡도
- 정의 : 입력 값에 따라 필요한 메모리 양
- 1000만까지는 어느 정도 가능하다.
###### 누적합
- 코드
```C++
void main() {
	std::vector<int> v = {1, 2, 3, 4, 5};
    for(int i = 1; i < v.size(); i++) {
        v[i] += v[i - 1];
    }
}
```
###### 팁
- 카운트를 세는 문제가 나오면 map(string을 키값으로 가지는 것들 혹은 후보군이 너무 많을때) or array(int를 키값)로 푼다.
- 시간은 이상 미만이다.
- 코딩 테스트는 개발이 아니다. (디테일하게 작성하지 않아도 된다.)
#### 문제 풀기 전 선수 지식
-  c++ 사용 시 코드 앞 부분에 아랫부분을 추가한다. (==`printf` 와 `cout` 둘 중에 하나만 써야 한다.==)
```C++
void main() {
	std::ios::sync_with_stdio(0); // printf 와 cout 의 동기화를 끊는다.
	std::cin.tie(0); // 입력 버퍼를 비우지 않느다.
}
```
- endl은 쓰지 않는다.
- 띄어쓰기가 있는 입력을 받을 때는 `getline()`을 사용한다.
- 정답의 끝에 공백 혹은 줄바꿈이 있어도 정답 처리가 된다.
- 배열을 특정 숫자로 채울 때는 `fill()`을 사용하면 간단하다.
- 시간 제한이 1초면 대략 1억번 정도 연산 가능한 코드를 짠다.
- 반례를 생각하는 법
	1. 최소, 최대를 입력해보자.
	2. 없거나 있거나를 체크해보자. (예외 사항이 있나)
- 변수명은 간결하나 통일성 있게 하자.
- 1억 이하의 시간복잡도는 항상 무식하게 풀 수 있는지 먼저 생각한다.
- 10!은 대략 360만 정도이다.
- 숫자 문자열은 항상 사이즈 먼저 비교한다.
- int 1000만개 이상은 메모리 제한에 걸린다.
- 0,1 은 ^1 을 했을 때 onoff가 가능하고 2, 3도 마찬가지 이다.
- 현재 위치에서 몇번을 이동해야 다시 원상복귀되는가(원형 배열에서)는 전체를 한번 %연산하는 것과 같다.
- 이분 탐색의 경우 현재 값이 x라면 될까라는 생각으로 풀려질 경우 사용한다.
- 이분 탐색의 경우 long long을 기본 타입으로 생각하는 것이 좋다.
- 소수값은 double을 쓰자.
- 그리디는 최선의 선택이 최적의 해를 보장할 때 사용한다.
- dp 문제에서 한번만 요소를 사용한다면 끝에서 부터 갱신, 여러번 사용은 앞에서 부터 갱신한다.
- 완탐 (경우의 수가 너무 많다) -> dp (배열을 만들기가 힘들다) -> 갯수를 이분해서 구현.
- 큰 수 만들기는 자릿수를 늘리는 것을 중점으로 생각하자.
- 배열 인덱스에 +1을 할 경우 cur % max_cnt로 값을 안전하게 방어 할 수 있으며 -1의 경우 (cur + max_cnt - 1) % max_cnt로 값을 방어 할 수 있다.
- 입력값을 알 수 없을때는 아래와 같은 형식으로 작성한다.
```cpp
int main() {
	int a, b;
	while (cin >> a >> b) {
		cout << a + b << '\n';
	}
	return 0;
}
```
#### 그래프
그래프 방문
1. 인접 행렬
```C++
bool bo[10][10];
bool vis[10];

void dfs(int v) {
	cout << v << ",";
	vis[v] = true;

	for(int i = 0; i < 5; i++) {
		if(bo[v][i] && !vis[i]) {
			dfs(i);
		}
	}
}

int main() {
	bo[1][2] = 1;
	bo[2][1] = 1;
	bo[1][3] = 1;
	bo[3][1] = 1;
	bo[3][4] = 1;
	bo[5][3] = 1;

	for(int i = 0; i < 10; i++) {
		if(!vis[i]) {
			dfs(i);
			cout << '\n';
		}
	}

	return 0;
}
```
2. 인접 리스트
```C++
vector<int> adj[10];
bool vis[10];

void dfs(int v) {
	cout << v << ",";
	vis[v] = true;

	for(int i = 0; i < adj[v].size(); i++) {
		if(!vis[adj[v][i]]) {
			dfs(adj[v][i]);
		}
	}
}

int main() {
	adj[1].push_back(2);
	adj[1].push_back(3);

	adj[2].push_back(1);
	
	adj[3].push_back(1);
	adj[3].push_back(4);

	adj[5].push_back(3);

	for(int i = 0; i < 10; i++) {
		if(!vis[i]) {
			dfs(i);
			cout << '\n';
		}
	}

	return 0;
}
```

차이
- 공간 복잡도
	1. 인접 행렬 : V x V
	2. 인접 리스트 : V + E
- 간선 하나 찾기
	1. 인접 행렬 : o(1)
	2. 인접 리스트 : o(E)
- 모든 간선 찾기
	1. 인접 행렬 : o(V * V)
	2. 인접 리스트 : o(V + E)

적절한 사용
- 연결된 간선이 많을 경우 인접행렬, 없을 땐 인접 리스트가 낫다.
- 코딩 테스트의 경우 보통은 인접 리스트가 괜찮다고 함.

양방향 탐색
```C++
int dx[] = {1, 0, -1, 0};
int dy[] = {0, 1, 0, -1};

int main() {
	int x = 1, y = 1;
	for(int i = 0; i < 4; i++) {
		int _x = x + dx[i];
		int _y = y + dy[i];
		cout << _x << "," << _y << '\n';
	}
	return 0;
}
```
###### dfs
>DFS는 Depth First Search의 약자로, 깊이 우선 탐색이라고도 부릅니다. 이름처럼, 최대한 깊게 탐색한 후 더 이상 도달할 수 없는 상황이라면 다시 이전으로 돌아갑니다. 그동안 배운 것을 잘 생각해보면 재귀라는 아이디어가 떠오를 것입니다. 실제로 DFS는 재귀를 활용해 구현하는 경우가 많습니다. 즉, 방문할 수 있는 지점이 있다면 그 지점을 방문하는 함수를 재귀적으로 호출하고, 더 이상 방문할 곳이 없다면 함수를 종료하면 될 것입니다. 다만 한가지 유의해야 할 점이라면, 이미 방문했던 지점을 또 방문하면 효율이 떨어지기 때문에 이전에 방문했던 지점은 다시 방문하지 않아야 한다는 점입니다. 즉, 한 번 방문한 지점은 어떤 처리를 해서 더 이상 방문하지 않도록 막아야 한다는 것입니다.
###### bfs
>다른 방식의 탐색 방법은 Breadth First Search 라고 하여, 너비 우선 탐색이라고도 부릅니다. 
>재귀(스택)을 활용했던 DFS와 달리, BFS를 큐를 사용합니다. 
>하나의 노드에 방문하게 되면, 그 노드와 인접한 노드 중 방문한 적이 없는 다른 노드를 모두 큐에 넣습니다. 우리는 큐가 FIFO 구조라는 것을 알기 때문에, 이런식으로 넣게 되면 이후엔 처음 넣었던 노드의 이웃 노드를 순차적으로 방문하게 될 것입니다.
###### 최단 거리
그래프 탐색을 배웠으니, 탐색 알고리즘을 사용하여 해결할 수 있는 문제를 하나 알아봅시다.

다음과 같은 길이 있다고 가정할 때, S 지점에서 E 지점까지 도달할 수 있는 방법 중 가장 짧은 방법의 길이를 구해봅시다.

![](https://contents.codetree.ai/problems/620/images/a03b28f5-1ed8-4691-88dc-c3e7e4d95a77.svg)

우리가 배운 것은 DFS와 BFS밖에 없기 때문에, 둘 중 적합한 방식을 고민해 봅시다.

사실 답은 정해져 있습니다. 바로 BFS입니다.

왜 그럴까요? BFS의 동작과정을 기반으로 찬찬히 생각해봅시다.

각각의 노드간의 거리를 1이라고 가정해 봅시다. S에서 방문을 시작하여 이웃 정점을 큐에 넣게 되면, 자연스럽게 큐에 있는 모든 정점은 S와의 거리가 1이 될 것이 분명합니다.

![](https://contents.codetree.ai/problems/620/images/91df41a7-832d-4c98-866b-497184d2dedb.svg)

마찬가지로, 1의 이웃들이 큐에 들어가게 된다면 1과의 거리가 1이므로 자연스럽게 S와의 거리는 2가 될 것 입니다.

![](https://contents.codetree.ai/problems/620/images/d1f27a4e-b36d-42d0-88fe-6ad9a2b53328.svg)

이런식으로 진행하게 되면, 자연스럽게 E에도 방문하게 되어 S와 E 사이의 거리를 구할 수 있을 것입니다. BFS는 정의상 시작점으로부터 가까운 지점부터 방문하게 되기 때문에 그림에서처럼 가중치가 전부 동일한 그래프에서는 최단거리를 확실하게 구해줄 수 있는 것입니다.
#### 트리
정의
노드끼리 전부 연결되어 있으면서 사이클이 존재하지 않는 그래프
###### 이진 트리
자식의 수를 최대 2개로 제한한 그래프
![img|600](https://contents.codetree.ai/problems/576/images/a3fb48e8-d849-44e0-a610-9134d50a8599.png)
###### 트리 용어 
![img|600](https://contents.codetree.ai/problems/574/images/6960f8d2-6881-46ed-8543-6961a3d57fd1.png)
###### 구현
>배열의 0번 값을 비우고, 루트 노드를 1번에 넣어주도록 합시다. 그리고 왼쪽 자식을 2번에, 오른쪽 자식을 3번에 넣어줍니다. 그 후 왼쪽 자식과 오른쪽 자식을 알맞게 넣어주면 됩니다.
>이렇게 넣게 되면, **특정 노드의 위치가 i라고 한다면, 자연스럽게 왼쪽 자식의 위치는 i * 2, 오른쪽 자식의 위치는 i * 2 + 1이 되는걸 볼 수 있습니다.** 즉, 이진트리는 배열로 구현이 가능하며 특정 노드 i의 자식 노드를 조회하기 위해서는 i * 2, i * 2 + 1을 하면 됩니다. **반대로 부모노드의 위치는 i / 2로 결정된다는 것을 어렵지 않게 알 수 있습니다.**
###### 이진 트리 순회
- 후위 순회(post order) : 자식(왼쪽부터) 방문 후 자신 방문
```C++
void postOrder(node) {
	if(!node) return;
	postOrder(node->left);
	postOrder(node->right);
	// do something...
}
```
- 전위 순회(preorder) : 자신 방문 후 자식(왼쪽부터) 방문
```C++
void preOrder(node) {
	if(!node) return;
	//do something...
	preOrder(node->left);
	preOrder(node->right);
}
```
- 중위 순회(inorder) : 왼쪽 노드, 자신, 오른쪽 노드 순위로 방문
```C++
void inOrder(node) {
	if(!node) return;
	inOrder(node->left);
	//do something...
	inOrder(node->right);
}
```
###### 이해하기 어려운 문제
이진 트리의 탐색 알고리즘 중 두 개의 결과를 알고 있다면 다른 하나의 결과를 알 수 있다.
만약 순회 결과과 아래와 같다면
	중위 탐색: 1-8-7-5-4-2-3-6
	후위 탐색: 1-7-8-5-2-6-3-4
위를 통해 전위 탐색의 결과는 아래와 같다.
	후위 탐색의 맨 마지막이 4이므로 루트 노드는 4이다.
	중위 탐색의 결과를 4를 기준으로 나누면 1-8-7-5(왼쪽), 2-3-6(오른쪽)으로 나눌 수 있다.
	후위 순회도 위와 같은 위치로 부터 나누면 1-7-8-5(왼쪽), 6-3-4(오른쪽)으로 나눌 수 있다.
	전위 탐색의 현재 방문 노드는 4이다.
	왼쪽부분과 오른쪽 부분을 재귀로 돌려 위의 방법을 반복한다.
###### 이진 탐색 트리 (Binary Search Tree)
**부모의 왼쪽 방향에 있는 노드들은 전부 부모 보다 값이 작고, 부모의 우측 방향에 있는 노드들은 전부 부모 보다 큰 값을 유지하고 있는 그래프의 형태.**
꼭 이진탐색 트리는 왼쪽, 오른쪽에 있는 **모든 노드**가 현재 노드보다 작고, 커야만 함에 유의
![img|600](https://contents.codetree.ai/problems/582/images/95efd20c-fe9a-45bd-9d2a-b9edd6a21f27.png)
>위의 트리는 이진 탐색 트리가 아님
###### 이진 탐색 트리 탐색 코드
```js
function bst.search(x)
    set node = bst.root                     
    while node != null and node.value != x  
        if node.value > x                   
            node = node.left               
        else                               
            node = node.right               
    
    return node
```
###### 이진 탐색 트리 삽입
**null에 도달하기 전까지 계속 진행**하여 값 x가 들어갈 위치를 찾아 삽입.
이때 새로운 노드를 추가하는 방법은 크게 3가지로 나뉨
- Case 1. 트리에 노드가 전혀 없는 경우
    이 경우에는 parent값이 null일 것이며, 이진 탐색 트리의 root를 node(x)로 설정
    
- Case 2. parent에 적혀있는 값이 삽입하려는 값 x보다 더 큰 경우
    이 경우에는 parent의 왼쪽에 node(x) 삽입
    
- Case 3. parent에 적혀있는 값이 삽입하려는 값 x보다 더 작은 경우
    이 경우에는 parent의 오른쪽에 node(x) 삽입
```cpp
function bst.insert(x)
    set node = bst.root          
    set parent = bst.root        

    while node != null           
        parent = node            
        if node.value > x        
            node = node.left     
        else                     
            node = node.right    
    
    if parent == null            
        bst.root = node(x)       
    else if parent.value > x     
        parent.left = node(x)    
    else                         
        parent.right = node(x)   
```
###### 이진 트리 삭제
먼저 x의 값을 찾는다. 그 후
- Case 1. 왼쪽 노드가 비어있는 경우
	오른쪽 노드로 현재 노드로 올려줌.
- Case 2. 오른쪽 노드가 비어있는 경우
	왼쪽 노드로 현재 노드로 올려줌.
- Case 3. 둘 다 존재하는 경우
	successor를 찾음. **successor란 현재 노드를 기준으로 더 크면서 가장 작은 값을 갖는 노드.**
	![img|600](https://contents.codetree.ai/problems/975/images/96576156-f003-4c2f-a2a5-eb389a2d3e8d.png)
	 node.right를 시작으로 계속 내려갈 수 있는 만큼 왼쪽으로 내려가는 방식으로 구할 수 있음.
	 successor를 구하고 나면, successor에 있는 값을 node에 옮겨준 뒤 successor의 오른쪽 자식을 위로 올려주면 됨.
	 successor가 target의 오른쪽 자식인 경우라면 1번째 case때 처럼 단순히 node의 오른쪽 노드를 위로 올려주면 됨
```js
function bst.search(x)
    set node = bst.root                     
    while node != null and node.value != x 
        if node.value > x                
            node = node.left           
        else                               
            node = node.right           
    
    return node            

function bst.minimum(node)                  
    while node.left != null                 
        node = node.left
    return node                             

function bst.delete(x)                      
    set node = bst.search(x)                
    
    if node.left == null                    
        move(node.right, node)              
    else if node.right == null              
        move(node.left, node)               
    else                                    
        set succ = bst.minimum(node.right)  
        if succ == node.right               
            move(node.right, node)
        else                              
            node.value = succ.value
            move(succ.right, succ)
```
###### 이진 트리 삽입/삭제/탐색의 시간 복잡도
삽입/삭제/탐색의 시간 복잡도는 모두 o(n)
>하지만 Red Black Tree나 AVL Tree같이 이진 탐색 트리를 특정 규칙에 따라 관리함으로서 **균형잡힌 이진 탐색 트리**를 유지하는 경우도 있습니다. 이는 삽입, 삭제가 일어나는 순간 **루트 노드**와 주위에 있는 노드를 회전 등의 작업을 통해 적절하게 조절하므로서 왼쪽 자식과 오른쪽 자식에 있는 노드간의 높이 차가 크게 벌어지지 않도록 하는 방법을 뜻합니다. 여기서 자세히 다루기에는 방대하고 복잡한 지식이라, 균형잡힌 이진 탐색 트리를 만들어 주는 방법이 있으며 이를 이용하면 트리의 높이를 항상 logN으로 유지시킬 수 있기 때문에 삽입, 삭제, 탐색의 시간이 O(logN)이 됨을 보장합니다.
###### 이진 트리의 중위 탐색
정렬된 형태로 탐색.
#### Heap
>힙이라 불리는 특별한 이진 트리. 힙 종류에는 max-heap, min-heap이 있으며, 이 자료구조를 이용하면 특정 수가 추가되고 삭제되었을 때 원하는 heap 구조를 유지하는 데 O(logn) 만큼이 소요되며, 이는 주어진 수들 중 최대 최소값을 O(1)에 구할 수 있도록 만들어줌.

완전 이진트리 : 트리의 모든 값이 왼쪽에서 순서대로 차 있는 것을 의미
![img|500](https://contents.codetree.ai/problems/589/images/eaa3c027-8edf-4241-9c5e-1a98dcbbef5c.svg)

완전 이진트리를 띄는 구조 안에서, 모든 노드에 대해 부모 노드가 자신의 자식 노드가 갖는 값보다 같거나 큰 경우를 만족한다면 이를 `max-heap` 혹은 반대의 경우 `min-heap`

>n개의 숫자들 중 최댓값을 단 한 번만 찾아야 하는 경우라면 max-heap을 만든 뒤 루트 노드를 봐야하므로 시간이 O(n)만큼 소요되기 때문에, 이 경우에는 간단히 순차탐색을 통해 O(n)에 최댓값을 찾는 것이 더 편리합니다. 이처럼 원소의 추가, 그리고 최댓값의 삭제가 빈번하게 일어나는 상황에서 현재 남아있는 원소들 중 최댓값을 빠르게 계속 얻고 싶은 경우에만 heap 자료구조가 유용
###### Heapifiy
```js
function heapify(arr[], n, i)
  set largest = i                     
  set l = i * 2                       
  set r = i * 2 + 1                   

  if l <= n && arr[l] > arr[largest]  
    largest = l

  if r <= n && arr[r] > arr[largest] 
    largest = r

  if largest != i                  
    swap(arr[i], arr[largest])     
    heapify(arr, n, largest)      
```
###### 삽입
현재 삽입된 기준으로 부모와 값을 계속 비교하며, 부모 값이 더 작다면 두 값을 교환해주는 것을 반복.
```js
function insert(arr[], n, x)
  arr.append(x)                     
  set i = n + 1                         
  while i > 1 and arr[i / 2] < arr[i]   
    swap(arr[i], arr[i / 2])             
    i = i / 2                           
```
###### 삭제
루트 노드와 끝 노드 교환 후 `heapifiy(1)`호출
```js
function remove(arr[], n) 
	arr[1] = arr[n] 
	delete arr[n] 
	heapify(arr, n - 1, 1) 
```
#### 해싱
![img|500](https://contents.codetree.ai/problems/597/images/a88418d6-3b33-42c5-8114-79694102e4a7.png)
>해시 함수는 임의의 데이터를 받아, 해당 데이터를 고정된 길이의 특정 값으로 반환하는 함수입니다. 즉, 어떤 값을 넣더라도 특정 범위에 해당하는 값을 반환합니다.

![img|500](https://contents.codetree.ai/problems/597/images/81e45539-64c8-40b7-a963-dfd4d6dc92aa.png)
> 해싱이랑 해시 함수를 이용하여 idx를 맵핑하여 최대한 o(1)에 가깝게 값을 찾을 수 있게 하는 알고리즘.
> 순서 상관 없이 각각의 데이터가 자주 들어오고 나가는 경우에 해싱이 꼭 필요하다는 사실을 기억하셔야 합니다.
###### index clamping
>예로 다음과 같이 숫자가 `239, 6, 197, 638, 372` 이렇게 주어져 있고, 해시 함수가 `f(x) = x`인 경우를 생각해봅시다. 해시 함수를 통해 나온 값을 저장할 수 있는 크기가 0에서 9 사이로 정해져 있다면, 다음과 같이 239, 197, 638, 372 등의 숫자는 제대로 저장되지 못할 것입니다. 하지만 만약 `f(x) = x % 10`으로 식을 세운다면, 모든 정보를 올바르게 저장할 수 있게 됩니다.

![img|500](https://contents.codetree.ai/problems/991/images/386ae950-10e5-4b40-9215-71208966ec77.png)
###### 해시 충돌
>다만, 다음과 같이 들어오는 숫자가 `239, 9, 199, 368, 372` 이렇게 달라진다면, 9 위치에서 숫자 3개 (239, 9, 199)를 저장해야만 하는 경우가 발생합니다. 이를 해시 충돌이라고 부릅니다.

![img|500](https://contents.codetree.ai/problems/991/images/6a0102b7-aa3e-478e-82ea-9340e4176007.png)

가장 간단한 해결법은 **연결 리스트**로 구현
![img|500](https://contents.codetree.ai/problems/991/images/46ea335f-5112-4300-a969-994880960e76.png)

하지만, 만약 해시 함수가 `f(x) = x % 10`이고, 주어진 데이터가 전부 숫자 9로 끝난다면, 삽입, 삭제, 탐색의 경우에 연결리스트를 순회해야 하므로 O(N)의 시간복잡도(해싱을 사용할 이유가 없음)

>보통 충돌 자체를 최대한 줄이기 위해, 실제로 들어갈 데이터보다 몇 배 정도 더 크게 배열을 정의합니다. 우리는 값이 저장되는 배열을 일반적으로 "해시 테이블"이라고 부르는데, 일반적으로 들어갈 최대 데이터의 3~4배 정도의 크기로 설정합니다.
#### DP
큰 문제에 대한 답을 얻기 위해 동일한 문제이지만 크기가 더 작은 문제들을 먼저 해결한 뒤, 그 결과들을 이용해 큰 문제를 비교적 간단하게 해결하는 기법

F(N)을 1부터 N까지의 곱이라고 정의한다면, 다음과 같이 점화식을 세워볼 수 있습니다.

```
- F(N) = F(N - 1) * N            (N > 1)           - 점화식
- F(1) = 1                                         - 초기조건
```

이를 코드로 구현할 수 있는 방법은 크게 2가지가 있습니다.

첫 번째는 for loop을 이용하는 것입니다.  
점화식을 통해 `F[i - 1]` 값이 구해졌다는 가정 하에서 `F[i]`값을 쉽게 구할 수 있으며, 초기 조건인 `F[1] = 1` 은 처음설정해주면 되므로 다음과 같이 코드 작성이 가능합니다.

```jsx
F[1] = 1
for i = 2 ... i <= n
    F[i] = F[i - 1] * i

print(F[n])
```

두 번째는 재귀함수를 이용하는 것입니다. 재귀함수를 이용하여 점화식을 표현하기 위해서는, **종료조건으로 초기 조건**을 넣어주고, 그렇지 않은 경우에는 점화식을 적어주면 됩니다.

코드는 다음과 같습니다.

```jsx
function f(n)
    if n == 1
        return 1
    else
        return f(n - 1) * n

print(f(n))
```

이처럼 동적계획법은 점화식을 기반으로 하는 방법이며, for문을 이용하여 해결할 수도 있고 재귀함수를 이용하는 것도 가능합니다.
###### Memoization
일단 기억을 떠올리기 위해 피보나치 수를 구하는 코드를 다시 한 번 보도록 하겠습니다.

```jsx
function fibbo(n)
    if n <= 2
        return 1
    else
        return fibbo(n - 1) + fibbo(n - 2)
```

이 코드를 통해 50번째 수를 구해주면, 엄청나게 오랜 시간이 소요되는걸 확인할 수 있습니다.
![img|600](https://contents.codetree.ai/problems/995/images/af9fd041-8911-442c-b6db-4c3a12109f3a.png)

자세히 본다면, 우리는 같은 결과를 너무 여러번 구하는 것을 볼 수 있습니다. 6번째 수를 구하기 위하여 4번째 수를 2번, 3번째 수를 3번, ... 구하게 됩니다.

그래도 별로 적은거 아니라고요? 50번째 피보나치 수를 구하기 위해선 fibbo 함수가 총 2,075,316,483회 실행됩니다. 따라서 시간이 엄청 길어질 수 밖에 없는 것이지요.

이런 문제를 해결할 수 있는 방법이 없을까요? 바로 **중복을 제거하면 됩니다 !!**
![img|600](https://contents.codetree.ai/problems/995/images/c326a9c6-0508-4934-8527-c16ee90eb138.png)

이를 가능하게 하기 위해 `memo`라는 배열을 이용해 볼 수 있습니다.  
처음에는 전부 -1로 초기화를 해놓습니다.
![img|600](https://contents.codetree.ai/problems/995/images/f99fa202-2f7b-43b0-b4c5-4d9a01aa2511.png)

이렇게 memoization을 고려해 코드를 새로 짜면, 다음과 같이 될 것입니다.  
memoization 이용시에는 함수 도입부에 -1이 아닌 경우 memo 값을 반환해주는 코드를 작성해주면 됩니다. 그렇지 않은 경우라면 반환해줘야 하는 값을 memo에 저장해준 뒤 해당 값을 반환해주면 됩니다.

```jsx
function fibbo(n)
    if memo[n] != -1           // 이미 n번째 값을 구해본 적이 있다면
        return memo[n]         // memo에 적혀있는 값을 반환해줍니다.
    if n <= 2                  // n이 2이하인 경우에는 종료 조건이므로 
        memo[n] = 1            // 해당하는 숫자를 memo에 넣어줍니다.
    else                       // 종료조건이 아닌 경우에는 
        memo[n] = fibbo(n - 1) + fibbo(n - 2)   // 점화식을 이용하여 답을 구한 뒤
                                                // 해당 값을 memo에 저장해줍니다.
    return memo[n]             // memo 값을 반환합니다.
```

이렇게 코드를 바꾸게 되면 기존에 O(2n) 시간복잡도를 갖던 코드가, 이제는 O(n)에 올바른 답을 구하게 됩니다. 이는 중복하여 탐색하는 경우가 아예 사라졌기 때문에 가능해진 것입니다.

재귀함수 이외에도, 동적계획법 문제를 해결할 수 있는 방법이 하나 더 있습니다. 이는 for문을 이용하는 방법으로, 순서대로 배열에 값을 채워나가는 방식입니다. 이를 **Tabulation**이라고 부릅니다.
```jsx
set dp = [0, 0, 0, ...]

dp[1] = 1
dp[2] = 1

for i = 3 ... i <= n:
    dp[i] = dp[i - 1] + dp[i - 2]

print(dp[n])
```
###### LIS(가장 긴 순열)
>증가하는 부분수열이란 숫자가 점점 증가하는 부분수열을 의미합니다. 예를 들어, `10, 30, 25, 40, 28, 45` 이라는 수열이 있다고 가정하면, `10, 30, 40` 같은 수열은 증가하는 부분수열이지만 `28, 40, 45`는 순서대로 나오지 않으므로 부분수열이 아닙니다.

첫 번째 숫자를 시작으로 계속 증가하는 값만 고른다고 해서 항상 LIS가 구해진다고 할 수는 없습니다. 예를 들어 주어진 수열이 `10, 30, 20, 22, 23, 24, 21`인 경우, `10, 20, 22, 23, 24`가 LIS가 됩니다.

`dp[i]`를 마지막으로 고른 원소의 위치가 i인 부분 수열 중 최장 증가 부분 수열의 길이라 정의해보겠습니다. 그렇다면 수열 `10, 30, 25, 40, 28, 45`에 대해 다음과 같이 DP 배열에 값이 채워져야 합니다.

| DP  | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
| --- | --- | --- | --- | --- | --- | --- | --- |
|     | -   | 1   | 2   | 2   | 3   | ... | ... |

`dp[1]`값이 1인 이유는 원소 10으로 끝나는 LIS가 `10`이기 때문이고,  
`dp[2]`값이 2인 이유는 원소 30으로 끝나는 LIS가 `10, 30`이기 때문이고,  
`dp[3]`값이 2인 이유는 원소 25로 끝나는 LIS가 `10, 25`이기 때문입니다.

이와 같이 수열을 이루고 있는 원소의 개수(N)가 적을 때는 직접 셀 수 있겠지만, N이 100인 경우만 해도 직접 계산하는 것은 불가능할 겁니다.

그렇다면 점화식을 세워야겠죠. 조금 고민해보면 i번째 원소를 고르기 직전에 골라진 원소의 위치가 j였을 경우를 1부터 i - 1까지 전부 가정해보며 다음과 같은 점화식을 세워볼 수 있을 것입니다. `dp[j]`는 위치 j를 마지막으로 하는 최장 부분 수열의 길이를 들고 있을 것이기 때문에, `dp[i]`는 `dp[j]`로부터 답이 갱신되어야만 합니다. 단, 직전에 있던 숫자 `a[j]`가 현재 숫자인 `a[i]`보다는 작아야 증가 수열이 유지가 될 것이므로, 해당 경우들 중 최댓값을 구해야 합니다.

![img|600](https://contents.codetree.ai/problems/811/images/f5fda046-fbfc-4dff-a60a-9fe5ed78a290.png)

처음 주어진 다음 예시에 대해 DP 테이블을 채워보도록 하겠습니다.

```
[10, 30, 25, 40, 28, 45]
```

먼저 전부 비워져 있는 상태로 시작합니다.

| DP  | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
| --- | --- | --- | --- | --- | --- | --- | --- |
|     | -   | -   | -   | -   | -   | -   | -   |
|     |     |     |     |     |     |     |     |

i = 1인 경우에는 앞에 조건을 만족하는 경우가 없으므로, 이런 경우에는 해당 원소를 증가 부분 수열의 시작 원소로 하는 것이 최선이므로 1을 적어줍니다.

|DP|0|1|2|3|4|5|6|
|---|---|---|---|---|---|---|---|
||-|1|-|-|-|-|-|

i = 2의 경우에는 j = 1일 때가 최적이므로 `dp[1] + 1`인 2가 됩니다.

| DP  | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
| --- | --- | --- | --- | --- | --- | --- | --- |
|     | -   | 1   | 2   | -   | -   | -   | -   |

i = 3의 경우에는 j = 1일 때가 최적이므로 `dp[1] + 1`인 2가 됩니다.

|DP|0|1|2|3|4|5|6|
|---|---|---|---|---|---|---|---|
||-|1|2|2|-|-|-|

i = 4의 경우에는 j = 2일 때가 최적이므로 `dp[2] + 1`인 3이 됩니다.

|DP|0|1|2|3|4|5|6|
|---|---|---|---|---|---|---|---|
||-|1|2|2|3|-|-|

이런 식으로 쭉 채워넣으면 다음과 같이 됩니다.

|DP|0|1|2|3|4|5|6|
|---|---|---|---|---|---|---|---|
||-|1|2|2|3|3|4|

DP 테이블을 전부 채우고 나면, 최대 증가 부분 수열은 어디에서 끝나도 상관 없으므로, DP 테이블에 적혀있는 값 중 최댓값은 4가 답이 됩니다.

```cpp
vector<int> arr = {60, 65, 50, 70, 63, 55, 45, 51, 45, 48, 54, 70, 61};

vector<int> dp(arr.size(), 1);
for(int i = 1; i < arr.size(); i++) {
	for(int j = 0; j < i; j++) {
		if(arr[i] > arr[j]) {
			dp[i] = max(dp[i], dp[j] + 1);
		}
	}
}
```
###### 아이템을 적절히 골라야 하는 경우
가치가 `1, 4, 5`인 3개의 동전이 주어졌을 때, 금액 8을 거슬러 주기 위해 필요한 최소 동전의 수를 구해보려고 합니다.

무턱대고 가치가 큰 동전부터 거슬러주면 `8 = 5 + 1 + 1 + 1`이 되어 4개의 동전이 필요해지게 됩니다. 하지만 이 경우 가치가 4인 동전을 2개 써서 8을 만들 수 있으므로 필요한 최소 동전의 수는 2가 됩니다.

이때 `dp[i]`를 지금까지 선택한 동전의 합이 i라 했을 때, 필요한 최소 동전 횟수라고 정의해보겠습니다. 그렇다면 위 예시에 대해서는 다음과 같이 DP table 값이 채워져야 합니다.

|DP|0|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|---|---|
||-|1|2|3|1|...|...|...|...|

수가 적으면 직접 셀 수 있겠지만, 거슬러줘야 하는 금액이 100인 경우만 해도 직접 계산하는 것은 불가능할 겁니다.

그렇다면 점화식을 세워야겠죠. 조금 고민해보면 총 n개의 동전 중 합 i를 만들기 위해 마지막으로 가치가 `coin[j]`인 j번째 동전을 고른 경우를 전부 가정해보며 다음과 같은 점화식을 세워볼 수 있을 것입니다.  
합 i를 만들어야 하기 때문에, 마지막으로 동전 `coin[j]`를 사용했다면 이전 동전들로 만들었어야 하는 합은 `i-coin[j]`일 것입니다. 따라서 `dp[i]`는 `dp[i-coin[j]]`에 동전 하나를 더 추가했으므로 1을 더한 값과 비교가 되어야 합니다. 단, i가 `coin[j]`보다 작다면 다음 경우는 불가능할 것이기 때문에 i가 `coin[j]`보다 같거나 큰 경우들 중 최솟값을 구해야 합니다.

처음 주어진 다음 예시에 대해 DP 테이블을 채워보도록 하겠습니다.

```
동전 종류 : 1, 4, 5
거슬러줘야 하는 금액 : 8
```

먼저 전부 비워져 있는 상태로 시작합니다. 이때, 합을 0 만드는 데 필요한 최소 동전의 수는 아무 동전도 사용하지 않은 경우이므로 0이 됩니다.

그 이후부터는 다음 점화식을 이용하여 값을 순서대로 채워넣으면 됩니다.

![img|600](https://contents.codetree.ai/problems/1006/images/647d27cd-dfa9-457e-b969-6a0211caf977.png)

![img|600](https://contents.codetree.ai/problems/1006/images/510549e7-462d-41bc-9e9c-f73382457bed.png)
합 8이 되기 위해 다음 3가지 경우가 있을 수 있습니다.

- Case 1. 마지막으로 사용한 동전이 가치가 1인 동전이었을 경우
    
    마지막으로 동전 1을 사용하여 합이 8이 되기 위해서는, 그 전까지의 합이 7이었어야 합니다.  
    따라서 `dp[7]`값인 3에 1을 더한 값인 4가 하나의 후보가 됩니다.
    
- Case 2. 마지막으로 사용한 동전이 가치가 4인 동전이었을 경우
    
    마지막으로 동전 4을 사용하여 합이 8이 되기 위해서는, 그 전까지의 합이 4였어야 합니다.  
    따라서 `dp[4]`값인 1에 1을 더한 값인 2가 하나의 후보가 됩니다.
    
- Case 3. 마지막으로 사용한 동전이 가치가 5인 동전이었을 경우
    
    마지막으로 동전 5를 사용하여 합이 8이 되기 위해서는, 그 전까지의 합이 3이었어야 합니다.  
    따라서 `dp[3]`값인 3에 1을 더한 값인 4가 하나의 후보가 됩니다.
    
최소 동전의 수를 계속 구해야 하므로, 이 3개의 후보 중 최솟값인 2가 `dp[8]`에 적히게 됩니다.

```cpp
// 목표 금액 : 21
// 동전 종류 : 1, 4, 5, 9
vector<int> dp(22, 0);

const int kind[] = { 1, 4, 5, 9 };
for(int i = 0; i < 4; i++) {
	dp[kind[i]] = 1;
}

for(int i = 1; i <= 21; i++) {
	dp[i] = INT_MAX;
	for(int j = 0; j < 4; j++) {
		if(i - kind[j] >= 0) {
			dp[i] = min(dp[i], dp[i - kind[j]] + 1);
		}
	}
}
```
#### 그리디
>현재 상황에서 최선이다 싶은 것을 계속 반복하는 알고리즘을 **그리디 알고리즘**, 욕심쟁이 기법이라 부릅니다. 

다음 문제를 살펴봅시다.

도둑이 보석방을 털러 갔습니다.  
이때 도둑 가방의 크기는 8이며, 이보다 더 많은 양의 무게에 해당하는 보석들을 담아 나올 수는 없습니다.  
또한, 보석은 종류별로 단 하나씩만 있습니다.

이 도둑방에 있는 보석의 무게와 가격은 다음과 같습니다.

|보석 번호|무게|가격|
|---|---|---|
|**1**|2|3|
|**2**|6|5|
|**3**|2|4|
|**4**|3|2|
|**5**|4|3|

이러한 문제의 경우 무게가 가벼운 것 부터 담았을 때가 최적이지 않은 경우도 있고, 가격이 높은 것 부터 담았을 때 역시 최적이 아닌 경우가 있습니다. 따라서 동적계획법을 이용하여야만 해결이 가능합니다.

하지만 만약 보석을 쪼개서 담을 수 있는 경우라면 문제가 어떻게 달라질까요? 위의 문제는 보석을 쪼개 담을 수 없고, 담거나 전혀 담지 않거나 하는 선택지 밖에 없기 때문에 **0/1 Knapsack** 문제라 불립니다. 이와는 다르게 쪼개서 담을 수 있는 문제의 경우 **Fractional Knapsack** 문제라 불리며, 이는 놀랍게도 동적계획법을 쓰지 않고도 해결이 가능합니다.

잘 생각해보면, 보석을 쪼개어 담을 수 있다면 항상 **무게 대비 가격이 높은 보석**을 우선적으로 담는 것이 항상 좋다는 것을 알 수 있습니다.

즉 위의 예시에서는, 무게가격​ 값이 큰 보석부터 담는 것이 항상 좋다는 것입니다. 무게가격​ 값을 내림차순으로 정렬하면 다음과 같기 때문에, 배낭의 크기를 넘지 않는 한 순서대로 보석을 담아주는 것이 항상 좋습니다.

|보석 번호|무게|가격|무게가격​|
|---|---|---|---|
|**3**|2|4|2|
|**1**|2|3|1.5|
|**2**|6|5|0.833|
|**5**|4|3|0.75|
|**4**|3|2|0.667|

이 예시에서는 처음 3번 보석을 담고, 1번 보석을 담으면 무게 4, 가격 7이 되며, 그 다음 보석인 2번 보석을 그대로 담으면 크기 8을 넘게 되므로 해당 보석 중 4/6 만큼만 잘라 담으면 담긴 보석의 무게는 8이 되며 가격은 7+5×64​=10.333이 됩니다. 따라서 해당 예시에서 얻을 수 있는 최대 가치는 10.333이 됩니다.

이러한 greedy 알고리즘이 Fractional Knapsack 문제에서는 실제 최적의 답을 가져와주게 됩니다. greedy 알고리즘은 비록 많은 문제에 대해 최적의 답을 가져와 주지는 못하지만, 그 방법이 굉장히 간단하기 때문에 최적의 답을 구하기 힘든 복잡한 문제에 대해 실제 답에 근사한 결과를 빠르고 간결하게 구하고 싶을 때 자주 사용되기도 합니다.
#### 누적합
응용 : imos 기법 : https://driip.me/65d9b58c-bf02-44bf-8fba-54d394ed21e0
#### 최단 거리
##### 다익스트라 알고리즘 (dijkstra algorithm)
>다익스트라 알고리즘 (Dijkstra Algorithm)은 **특정 시작점**에서 **다른 모든 정점**으로 가는 최단거리를 각각 구해주는 알고리즘입니다. 즉, 5개의 정점이 있고 1번 정점에서 출발한다고 가정하면, 1번에서 2~5번으로 가는 최단거리를 구해주는 것 입니다.
>우리가 다른 지점까지의 거리는 모르지만, A라는 지점까지 가는 최단거리는 확실히 안다고 가정해봅시다. 그렇다면 A를 거쳐 다른 지점을 갈 수 있다면, 우리는 현재 아는 정보로 특정 지점까지 거리 = A까지 가는 거리 + A에서 특정 지점까지 소요되는 거리라고 추측할 수 있을 것 입니다. 다익스트라는 이 아이디어를 기반으로 설계된 알고리즘입니다.

![](https://contents.codetree.ai/problems/624/images/87140b7f-4319-447b-8c1e-bafdeb1a7aee.svg)

5번을 시작점으로 했을 때, 각 지점에 도달하기 위한 최단거리를 구한다고 가정해보겠습니다.  
그렇다면 다익스트라 알고리즘에서는, 거리 배열을 전부 아주 큰 값(INF)으로 초기화하고, 출발지의 값만 0으로 설정하게 됩니다. 시작점만 0으로 설정해주는 까닭은, 최단거리가 0임을 분명하게 알 수 있기 때문입니다.

![](https://contents.codetree.ai/problems/624/images/4dda566d-4d7f-4cdc-9ff7-07504802f17a.svg)

이제 거리 배열(dist) 내의 값들 중 최솟값을 골라줍니다. 이렇게 최솟값을 골라주는 과정을 다익스트라 알고리즘에서는 여러 번 반복하게 되는데, 이런 경우에 효과적으로 최솟값을 계속 찾아주기 위해서는 **우선순위 큐**를 이용해야 한다고 했었습니다. 따라서 우리는 처음 시작할 때부터 1번부터 5번 정점까지 전부 우선순위 큐에 넣어 거리 값 중 최솟값을 골라줄 수 있도록 합니다.

![](https://contents.codetree.ai/problems/624/images/abf820a3-9045-4cdb-9fc6-e0e5b70aeb68.svg)

처음 거리가 최솟값인 노드를 고르면 5번 노드가 선택됩니다. 이렇게 최솟값이 뽑혔다는 의미는, 시작점으로부터의 뽑힌 노드까지의 최단거리는 확실히 정해졌다는 뜻이기도 합니다. 이때 우선순위 큐에서 5번 노드는 빠지게 됩니다.

![](https://contents.codetree.ai/problems/624/images/4b80c2c6-edca-476a-8023-6cf0146e5f4f.svg)

이제 이 5번 노드에 연결된 노드들을 보며 `dist[5]`에 간선에 적혀있는 값을 더했을 때 해당 노드에 적혀있는 dist값과 비교하여 더 작은 값으로 갱신해줍니다.

![](https://contents.codetree.ai/problems/624/images/d62030cc-ad4a-449c-9b3b-8dd1703500b7.svg)

이 과정을 거치면 `dist[2]`는 아주 큰 값인 INF였으므로 `dist[5] + 4`에 해당하는 값 4로 바뀌게 되며, `dist[4]` 역시 아주 큰 값인 INF였으므로 `dist[5] + 2`에 해당하는 값 2로 바뀌게 됩니다.

![](https://contents.codetree.ai/problems/624/images/f0433692-b140-4387-b6ee-94103dfd8d54.svg)

그 다음 우선순위 큐에 담겨있는 노드들 중 dist 최솟값을 갖고 있는 노드를 고르게 되면, `dist[4]`값이 2 이므로 4번 노드가 골라지게 됩니다.

![](https://contents.codetree.ai/problems/624/images/e399b0b5-b606-48fb-ad6b-462595d83a4e.svg)

4번 노드에 대해서도 연결된 간선들을 보며 최솟값으로 갱신해주는 작업을 거치게 됩니다.

![](https://contents.codetree.ai/problems/624/images/b3490ff7-941b-4ddc-a2c4-4a6e2ba63d89.svg)

이 과정을 거치면 `dist[3]`는 아주 큰 값인 INF였으므로 `dist[4] + 2`에 해당하는 값 4로 바뀌게 되며, `dist[2]`의 경우 원래 값이 4였지만, `dist[4] + 1`이 3으로 더 작기 때문에 값이 3으로 바뀌게 됩니다.

![](https://contents.codetree.ai/problems/624/images/1dc41dbb-b79a-4b8a-87a6-72e7bfbaae4e.svg)

모든 지점이 선택될 때까지 이 과정을 계속 반복하면, 최종적으로 dist 배열에 적혀있는 값들이 5번 정점을 시작으로 하여 각 지점에 도달하는 최단거리가 됩니다.

![](https://contents.codetree.ai/problems/624/images/b845fb7c-5de0-4df2-845f-17f8b0eec362.svg)

그래프 내의 정점의 수를 |V|, 간선의 수를 |E|라 했을 때 이 알고리즘의 시간복잡도는 O(∣E∣log∣V∣)가 됩니다. 그 이유는 다익스트라 알고리즘을 진행하면 각 간선을 한 번씩 보게 되는데, 이때 dist값이 변하면 우선순위큐에서의 순서가 계속 바뀌게 될 수도 있으므로 간선의 수 × 우선순위 큐 이용 시간복잡도가 됩니다.

만약 우선순위 큐를 이용하지 않고, for 문을 이용해 최솟값을 찾는 식으로 코드를 구현한다면, 최솟값에 해당하는 노드를 고르는데 |V|번 시간이 소요되고 이 과정을 총 |V|번 반복해야 모든 노드를 선택하게 되므로 시간복잡도는 O(∣V∣2)이 될 것입니다.

다익스트라 알고리즘의 동작과정을 다시 한번 살펴보면 다음과 같습니다.

수도 코드
```jsx
function dijkstra(graph, source)              // 그래프와 시작점 정보가 주어집니다.
    set Q = Queue()                           // 우선순위 큐를 만들어줍니다.

    for each vertex in graph                  // 그래프에 있는 모든 노드들에 대해
        set dist[v] = INF                     // 초기값을 전부 아주 큰 값으로 설정해주고 
        Q.push(v)                             // 우선순위큐에 각 노드를 넣어줍니다.

    set dist[source] = 0                      // 시작점에 대해서만 dist 값을 0으로 초기화해줍니다.
    while Q is not empty                      // 우선순위 큐가 비어있지 않을 때까지 반복합니다.
        set u = vertex in Q with min dist     // 우선순위 큐에서 dist값이 가장 작은 노드를 선택합니다.
        Q.remove(u)                           // 우선순위 큐에서 해당 노드를 제거해줍니다.

        for each neighbor v of u              // u번 노드와 연결된 노드들을 전부 살펴보면서
            set alt = dist[u] + length(u, v)  // 현재 dist값에 간선 가중치를 더한 값을 계산하여
            if alt < dist[v]                  // 기존 dist값보다 더 alt값이 작다면
                set dist[v] = alt             // dist값을 갱신해줍니다.
```

코드 구현
```cpp
int dijkstra(vector<vector<pair<int, int>>& adj, int start, int end) {
	priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
	vector<int> vis(n + 1, MAX);
	pq.push({0, start});
	vis[start] = 0;
	while(pq.size()) {
		pair<int, int> pa = pq.top();
		pq.pop();
		if(pa.first > vis[pa.second]) continue;
		for(int i = 0; i < adj[pa.second].size(); i++) {
			int nxt = adj[pa.second][i].first;
			int cost = adj[pa.second][i].second;
			if(pa.first + cost >= vis[nxt]) continue;
			vis[nxt] = pa.first + cost;
			pq.push({vis[nxt], nxt});
		}
	}
	return vis[end];
}
```

그런데 다음 그래프에서도 다익스트라 알고리즘이 올바르게 동작할까요?

![img|600](https://contents.codetree.ai/problems/624/images/0e8585a3-6701-4b80-8f0f-e0cc9c640eb5.png)

`dist[5]`가 처음 잡히게 되어 `dist[2]`가 1, `dist[4]`가 2로 갱신되고, 그 다음 최소인 `dist[2]`가 잡히게 되어 `dist[1]`은 `dist[2] + 3`인 4로 갱신이 될 것입니다.

하지만 5번 정점에서 1번 정점으로 가는 최단거리는 5 → 4 → 2 → 1 을 통해 가면 3만에 갈 수 있습니다. 이처럼 **음수 가중치가 있는 그래프** 에서는 다익스트라가 올바르게 동작하지 않을 수 있습니다. 그 까닭은, 다익스트라에서는 dist중 가장 작은 값을 골랐을 때 그 값이 확실한 최단거리라는 보장이 되어야 하는데, 음수 가중치가 있으면 다시 골라졌던 정점에 도달하는 dist값이 더 작아질 수도 있기 때문에 최단거리임을 보장할 수 없게 됩니다.

따라서 음수 가중치가 있을 때의 최단거리는 다익스트라를 이용해서는 절대 구할 수 없습니다.
##### 플루이드 워셜(Floyd Warshall)
>가끔은 모든 지점의 거리를 알 필요가 있습니다. 그러나 다익스트라의 경우 한 지점에서 다른 지점으로 가는 최단거리만 제공하기 때문에, 모든 지점의 거리를 확인하기 위해선 각각의 지점에 대해 다익스트라를 한번 씩 돌려야 합니다. 굉장히 번거롭죠. 정점의 수를 V, 간선의 수를 E라 했을 때 다익스트라를 이용하여 한 시작점으로부터 다른 지점들 까지의 최단거리를 구하는데 시간복잡도가 간단한 방법으로는 O(V2), 우선순위 큐를 썼을 때는 O(ElogV)이었습니다. 이때 만약 모든 쌍에 대해 최단거리를 구하고 싶다는, 시작점을 모든 정점에 대해 지정해줘야 하므로 총 V번이 되어 시간복잡도는 O(V3) 혹은 O(VElogV)가 될 것입니다. 만약 그래프에 간선이 굉장히 많은 경우라면 E=V2이 되므로, 이런 경우라면 O(V3)이 더 효율적일 것입니다. 이처럼 모든 쌍에 대해 최단거리를 구해야하는 상황에서 사용하기에 아주 좋은 알고리즘이 존재하는데, 우리는 이것을 플로이드 워셜 알고리즘 (Floyd-Warshall Algorithm) 이라고 부릅니다.

다음 그래프를 예시로 플로이드 워셜 알고리즘을 한번 진행해보도록 하겠습니다.

![](https://contents.codetree.ai/problems/1016/images/847f12dd-2c25-4fe7-87dd-212efd0a7acd.svg)

먼저 V2 크기의 배열(dist) 내에 있는 모든 값을 최댓값은 INF로 채워줍니다.

![](https://contents.codetree.ai/problems/1016/images/d0031d7b-bb15-48bb-9845-6988bbd2315f.svg)

이후 주어진 그래프에서 각 간선에 적혀있는 숫자들을 dist 배열에 적어줍니다. 단, `dist[i][i]`는 자기 자신으로 가는 최단거리 이므로 값 0을 꼭 적어줘야만 합니다.

![](https://contents.codetree.ai/problems/1016/images/d4320ed4-4c41-4ca5-a4ec-2075c97bd8cd.svg)

그 다음부터는 노드 1부터 시작하여 N번 노드까지 순서대로 경유했을 때를 가정합니다.  
먼저 모든 쌍 (i, j)에 대해 노드 1을 경유하는 것이 더 좋은 경우 그 값을 갱신해줍니다. 즉, `dist[i][j] > dist[i][1] + dist[1][j]`를 만족하는 경우 `dist[i][j]`에 `dist[i][1] + dist[1][j]`값을 넣어줍니다.

![](https://contents.codetree.ai/problems/1016/images/fa7de6ed-df13-46ea-bbd4-a29ee0571da2.svg)

다음 2번 노드에 대해서도 해당 노드를 경유하는 것이 더 좋은 경우 그 값을 갱신해줍니다. 즉, `dist[i][j] > dist[i][2] + dist[2][j]`를 만족하는 경우 `dist[i][j]`에 `dist[i][2] + dist[2][j]`값을 넣어줍니다.

![](https://contents.codetree.ai/problems/1016/images/c0cc793a-bcf1-43a3-a002-09356aca22da.svg)

이렇게 N번 노드까지 전부 진행하게 되면, dist 배열에 각 쌍에 대한 최단거리가 남게 됩니다.

이 알고리즘은 쉽게 작성할 수 있다는 장점이 있지만, 3중 반복문을 돌리다보니 O(V3)으로 상당히 비효율적이라는 단점이 있습니다. 따라서 정점의 수가 많지 않거나 모든 쌍에 대한 최단거리를 구해야만 할 때 사용하는 것이 좋고, 정점의 수가 많아진다면 필요한 지점들에 대해서만 다익스트라를 돌려서 해결하는 것이 좋습니다.

플로이드 워셜 코드는 다음과 같습니다.

```jsx
function floyd(graph)
    set dist = |V| * |V| array initialized to INF  // 처음 dist 배열을 아주 큰 값인 INF로 초기화합니다.
    for each edge(u, v)                            // 주어진 그래프의 모든 간선에 대해
        dist[u][v] = length(u, v)                  // 각 간선의 가중치를 dist 배열에 적어줍니다.
    for k = 1 ... |V|                              // 확실하게 거쳐갈 정점을 1번부터 V번까지 순서대로 정의합니다.
        for i = 1 ... |V|                          // 고정된 k에 대해 모든 쌍 (i, j)를 살펴봅니다.
            for j = 1 ... |V|
                if dist[i][j] > dist[i][k] + dist[k][j]     // i에서 j로 가는 거리가 k를 경유해 가는 것이 더 좋다면
                    dist[i][j] = dist[i][k] + dist[k][j]    // dist[i][j]값을 갱신해줍니다.
    return dist
```
###### Kruskal algorithm

**Union find**
여러 개의 원소가 있고, 여러 개의 집합이 있다고 가정합시다. 특정 원소가 어떤 집합에 속해있는지 확인하고, 특정 집합을 합쳐야 할 일이 있다면 Union-Find 자료구조를 사용하면 좋습니다.

먼저 모든 노드가 연결되어 있지 않은 상황에서 시작합니다.  
또, **uf 배열의 초기값은 자기 자신입니다.** 이때, uf는 그룹 번호를 뜻합니다. 따라서 처음에는 모든 노드가 전부 다른 그룹에 있게 됩니다.

![](https://contents.codetree.ai/problems/633/images/ae53814f-f536-48d1-8aaa-f2ab508ed30e.svg)

`union()` 연산을 사용하면, 두 노드가 같은 곳에 속해있음을 표시해줄 수 있습니다. 예를 들어 1과 3을 연결하려고 한다면, `uf[1]`값에 3을 적어주면 됩니다.

![](https://contents.codetree.ai/problems/633/images/4140e89a-dfe8-41a9-ba3a-962e9ffb0548.svg)

`union(5, 6)`의 경우에도 `uf[5]`값에 6을 적어주면 됩니다.

![](https://contents.codetree.ai/problems/633/images/13571091-9246-4947-9495-500575620f6a.svg)

이렇게 union을 이용해 두 노드를 합치게 되면 **uf 배열의 값은 그룹으로서의 의미 뿐만이 아니라, 실제 노드가 현재 가리키고 있는 부모 노드의 번호가 됩니다.**

이 상황에서 `union(5, 1)`을 진행하면 이때는 움직임이 조금 달라집니다.

먼저, 두 노드 모두 부모 노드를 따라 올라 갈 수 있는데 까지 계속 올라가야 합니다. 이 과정을 `find()`라고 하며, 이는 `x와 uf[x]`값이 같아지기 전까지 계속 올라가는 것으로 구현이 가능합니다. 예를 들어 find(5)는 6이 나와야 하며, find(1)는 3이 나와야 합니다.

각 노드에 대해 find를 진행하게 되면, 두 노드 각각 루트 노드인 6, 3을 가리키게 됩니다. 이렇게 골라진 루트 노드가 X, Y였다면, `uf[X]`에 Y를 넣어주면 됩니다. 즉, 여기서는 `uf[6]`에 3을 넣어주게 됩니다.

![](https://contents.codetree.ai/problems/633/images/a545c49e-9189-4fd5-afb8-b7e28150a40c.svg)

즉 union이라는 함수는 다음과 같이 적어볼 수 있습니다.

```jsx
function union(x, y)
  set X = find(x), Y = find(y)
  uf[X] = Y
```

그렇다면 find 함수는 어떻게 구현해볼 수 있을까요? x로 시작하여 계속 `uf[x]`를 따라가다가, 더 이상 따라갈 곳이 없을 때(`uf[x] == x` 조건을 만족하는 경우)의 x 값을 반환하면 될 것입니다.

```jsx
function find(x)
  if uf[x] == x        // x가 루트 노드라면
    return x           // x 값을 반환합니다.
  return find(uf[x])   // x가 루트 노드가 아니라면, x의 부모인 uf[x]에서 더 탐색을 진행합니다.
```

즉, `find(x)`함수는 x 노드가 포함된 집단의 루트 노드를 찾아줌과 동시에, 이 루트 노드가 그 집단을 대표하는 대표 번호가 됩니다. 다음 그림에서 1, 3, 5, 6번 노드는 모두 대표 번호가 3번이 됩니다.

![](https://contents.codetree.ai/problems/633/images/a545c49e-9189-4fd5-afb8-b7e28150a40c.svg)

여기에 `union(4, 1)`를 한번 진행하게 되면, 4의 루트 노드는 4, 1의 루트 노드는 3 이므로 다음과 같이 그림이 바뀌게 됩니다.
![img](https://contents.codetree.ai/problems/633/images/a7343c17-f716-4c25-80ca-64a4a7f05d5e.svg)

Union-Find는 꽤나 쓸만한 자료구조이지만, 약간 문제가 있습니다.

다음과 같이 모든 집합들이 합쳐있다고 가정합시다.

![](https://contents.codetree.ai/problems/635/images/cf0243e7-53ce-4634-9306-30cf0b6d5785.svg)

이런 경우, 9번에 대해 find를 호출하면 조상을 찾을 때 까지 계속 앞으로 나아가야 하고, 결국 O(N)이라는 시간이 소요됩니다. 사실 이렇게 되면 굳이 자료구조를 만들면서까지 사용할 이유가 없어지죠. 왜냐하면 일반 배열을 만들어서 O(N)에 각 노드가 어디에 해당하는지를 표기해주는 식으로도 충분히 union, find 함수를 흉내낼 수 있기 때문입니다.

그래서 개선책이 등장하였습니다. find를 호출할때 조상을 찾아내면, 현재 값의 부모값을 조상으로 바꿔버리는 것입니다.

현재 집합 구조가 다음과 같다고 가정해 봅시다.

![](https://contents.codetree.ai/problems/635/images/69cb9f21-19cc-4db6-b418-b85b56fef83d.svg)

여기서 `find(5)`가 수행되었을 때, 5 위에 있는 모든 노드들을 전부 루트 노드인 3으로 옮겨버리겠다는 뜻입니다. 마치 다음과 같이요.

![](https://contents.codetree.ai/problems/635/images/f2bb2af1-6438-4f88-8bb4-e7567f77da73.svg)

맨 앞에서 봤던 다음 예시에서, find(9)가 실행된다면 결과가 어떻게 바뀐다는 것일까요?

![](https://contents.codetree.ai/problems/635/images/05a454f2-fc26-4075-bc5b-054e833e2e15.svg)

바로 다음과 같이 9 위에 있는 모든 노드들이 전부 노드 1을 가리키게 한다는 것입니다.

![](https://contents.codetree.ai/problems/635/images/6f054631-e40c-40b9-a70f-83938fcaeff9.svg)

이것이 만약 가능하다면, find 함수가 호출될 때마다 탐색했던 모든 노드가 전부 root로 붙게 되 깊이가 전부 1로 바뀌게 되므로, 이후 동일한 노드를 탐색하게 될 경우 시간이 거의 소요되지 않게 됩니다. 즉, 중복 탐색하는 경우가 많이 사라지게 됩니다. 이러한 방법을 **경로 압축(Path Compression)** 이라고 부르며, 이 방법을 union-find에 적용하면, union, find 함수의 시간복잡도가 모두 O(logN)이 됩니다.

이 경로 압축 기법에 대한 구현은, 기존 find 함수에 몇 줄만 수정해주면 됩니다.

기존 find 함수는 다음과 같았습니다.

```jsx
function find(x)
  if uf[x] == x        // x가 루트 노드라면
    return x           // x 값을 반환합니다.
  return find(uf[x])   // x가 루트 노드가 아니라면, x의 부모인 uf[x]에서 더 탐색을 진행합니다.
```

여기서 `find(uf[x])`부분만 다음과 같이 수정하면 됩니다.

```jsx
function find(x)
  if uf[x] == x                 // x가 루트 노드라면
    return x                    // x 값을 반환합니다.
  set root_node = find(uf[x])   // x가 루트 노드가 아니라면, x의 부모인 uf[x]에서 더 탐색을 진행합니다.
  uf[x] = root_node             // 노드 x에 부모를 루트 노드로 설정해줍니다.
  return root_node              // 찾아낸 루트 노드를 반환합니다.
```

기존에는 루트 노드를 찾아 바로 반환해줬었는데, 이제는 반환 전에 거쳐가게 되는 모든 노드 x에 대해 `uf[x]`값을 루트 노드로 바꿔준 뒤, 루트 노드를 반환해주면 됩니다.

**MST**
N개의 도시가 있는데, 그래프 구조로 되어 있는 길을 모두 건설할 돈이 없어서 최소한의 비용만 투자하여 모든 도시를 어떻게든 이어주려고 합니다. 즉, 다음과 같은 방식으로 길을 선택하려는 것이지요.

![img|600](https://contents.codetree.ai/problems/632/images/b72705f3-95d3-40da-95cc-64c86a6e33ac.png)

우리는 최소한의 간선을 사용하여 그래프 내 모든 정점을 이어준다면, 그것을 Spanning Tree라고 부를 것 입니다. 왜 이게 트리냐고요? 놀랍게도 N개의 정점에 N-1개의 간선이 존재하는 그래프는 트리입니다. 실제로 위의 예제 같은 경우도 위치를 약간 바꿔주면 다음과 같이 우리에게 친숙한 트리가 보입니다. 트리는 사이클이 없으며, 모든 노드들이 다 연결되어있다는 특징을 갖고 있습니다.

![img|600](https://contents.codetree.ai/problems/632/images/7bac6c77-5c3d-4162-b974-33142b45d381.png)

이것은 가중치가 없을 때의 일이고, 가중치가 있다면 조금 이야기가 달라집니다. 똑같이 N-1개의 간선을 채택하였다 하더라도 상황에 따라 가중치의 합이 다를 수 있으므로, 최소한의 비용을 사용하기 위해선 특정한 경로를 채택해야 할 것입니다.

![img|600](https://contents.codetree.ai/problems/632/images/695e4656-8559-438d-b1a9-08061fa60f91.png)

우리는 가중치가 있을때 최소한의 비용을 사용한 Spanning Tree를 Minimum Spanning Tree라고 부르고, 일반적으로 줄여서 MST라고 부릅니다.

**크루스컬 알고리즘 (Kruskal Algorithm)**

아이디어는 쉽습니다. MST는 가중치의 합을 최소로 하는 Spanning Tree이니, 가중치가 작은 간선부터 고르는 것 입니다.

다음 그래프에서 크루스컬 알고리즘을 생각해보겠습니다.

![](https://contents.codetree.ai/problems/638/images/8f340695-cbaa-4026-a5d4-8c91d3591e95.svg)

먼저 가중치가 가장 작은 1이 적혀있는 간선을 고르게 됩니다.

![](https://contents.codetree.ai/problems/638/images/61a375c8-4b13-4477-a12f-5b7d5ec3e79a.svg)

순서대로 고르면 됩니다. 다만, 같은 가중치를 갖는 간선이 여러 개인 경우 그 중 아무 간선이나 고르시면 됩니다.

이제 가중치가 5인 간선까지 골라졌다고 생각해보겠습니다.

![](https://contents.codetree.ai/problems/638/images/95a35ab3-ab2d-418c-833b-6c216f679614.svg)

그 다음 가중치가 6인 간선을 고르고자 하는 찰나에, 만약 6인 간선을 고르게 되면 다음과 같이 사이클이 발생하게 됩니다!

![](https://contents.codetree.ai/problems/638/images/eda9e15d-6c93-491d-8165-60f881861991.svg)

노드의 수가 3개라면 당연히 간선이 2개가 되어야 MST가 될텐데, 다음과 같이 사이클이 발생하면 깨지게 됩니다. MST에서 가장 중요한 성질은, 트리이기 때문에 절대 사이클이 생겨서는 안됩니다.

그렇다면 결국 사이클이 발생하지 않도록 해야하는건데, 어떻게 찾아낼 수 있을까요? 답은 바로 앞에서 배웠던 **Union-Find** 입니다.

방법은 간단합니다. 특정 간선을 선택하면, 두 노드에 union 연산을 수행합니다. 그렇게 되면 같은 집합이 될 것입니다. 만약 사이클이 발생하게 된다면, 이미 두 노드는 같은 집합에 속한 상태이니, 미리 체크하여 같은 집합이라면 합치지 않고 넘어가는 겁니다!

위의 경우에서는 가중치가 6인 간선이 골라졌을 경우에 노드 5번과 노드 8번이 같은 루트 노드를 두고 있는지를 판단했어야 합니다. 즉, `find(5)`와 `find(8)`가 동일하다면 간선을 추가하면 안된다는 뜻입니다.

이처럼 크루스칼은, 간선의 가중치가 작은 것부터 순서대로 보면서 해당 간선 양 끝에 있는 두 노드 x, y에 대해 find(x), find(y)값을 비교하여 일치하지 않는 경우에만 간선을 선택해주고 union(x, y)를 진행해주는 식으로 계속 진행하면 됩니다.

따라서 가중치가 6인 간선은 선택되지 않고, 그다음 가중치인 7을 보게 되었을 때, find(5)와 find(7) 값은 다르기 때문에 다시 간선을 선택하며 union(5, 7)을 거치게 됩니다.

![](https://contents.codetree.ai/problems/638/images/9a5064e2-c926-4a6f-8755-f6d399495d07.svg)

이러한 과정을 모든 간선에 대해 진행하면, 그래프에서 노드의 수를 N이라 했을 때 최종적으로 선택된 간선의 수는 N - 1개가 되며, 이 N - 1개의 간선이 결국 MST를 이루게 됩니다.

따라서, Union-Find를 활용하면 크루스컬 알고리즘은 정렬 한 번이면 쉽게 구현할 수 있습니다. 그래프 내 간선의 수를 E라 했을 때, 간선을 정렬하는 데 O(ElogE)이며, 각 간선에 대해 union-find는 O(logN)이므로 ElogE+ElogN가 되어 총 시간복잡도는 O(ElogE)가 됩니다.

크루스컬 알고리즘 코드는 다음과 같습니다.

```jsx
function kruskal()
    mst = []                       // mst를 담을 배열입니다.
    sort edge[] by length          // 간선을 가중치 기준으로 오름차순 정렬합니다.
    uf = uf_init(|V|)              // uf 배열을 노드의 수 |V|만큼 초기화합니다.

    for E in edge[]                // 각각의 간선에 대해 
        u, v = E                   // 간선을 이루고 있는 두 노드 u, v를 보며
        if find(u) != find(v)      // u, v의 루트 노드가 다른 경우에만
            mst.push(E)            // mst에 해당 간선을 넣어주고
            union(u, v)            // u, v를 같은 루트 노드를 갖도록 만들어줍니다.
    
    return mst
```
##### 프림 알고리즘(Prim algorithm)
전체에서 간선을 선택하는 크루스컬과 반대로, 프림 알고리즘은 한 지점에서 시작하여 점점 확장을 진행하는 방법입니다. 다음 그래프를 이용하여 설명을 진행해보겠습니다.

![](https://contents.codetree.ai/problems/1020/images/7ad0707d-5dfd-437c-9fe7-5befaab81240.svg)
프림 알고리즘은 아무 정점에서나 시작하면 됩니다. 편의상 1번 정점에서 시작해보겠습니다.

![](https://contents.codetree.ai/problems/1020/images/a2c3b256-b3bc-4c0d-95e7-fbaeada38969.svg)

이제 1번 정점에서 연결된 간선들 중 가중치가 가장 작은 간선을 고르면 됩니다. 따라서 가중치가 11인 간선이 선택되며, **이 간선이 MST에 들어가게 됩니다.**

![](https://contents.codetree.ai/problems/1020/images/5a057961-6365-4aa1-bd9e-48fb54683a40.svg)

이제 MST를 이루고 있는 간선은 1-3 뿐입니다. 이 MST에 새로운 노드를 붙이기 위한 방법 중, 가중치가 가장 작은 간선을 고르면 1-2를 연결하는 가중치가 12인 간선 입니다. 그 간선을 골라 MST에 붙여줍니다.

![](https://contents.codetree.ai/problems/1020/images/55a5dd05-3894-4808-83e0-d3cb2464fbec.svg)

그 다음 MST에 새로운 노드를 붙이기 위한 최소 가중치의 간선은 14입니다. 13을 붙여서는 안되는 이유는, 이미 MST에 포함된 노드끼리의 연결이므로 MST에 새로운 노드가 포함되는 것이 아니기 때문에 추가시 사이클이 발생하기 때문입니다.

![](https://contents.codetree.ai/problems/1020/images/b6c46d1f-25b1-415a-a78a-1e71d1807ece.svg)

이러한 과정을 계속 거치다보면, 모든 노드가 MST에 포함되었을 때 종료가 되며 저희가 구하고자 하는 MST의 모습이 확정됩니다.

이 과정에 대한 구현은 놀랍게도 다익스트라 알고리즘과 아예 동일합니다. 다익스트라 알고리즘의 경우, 현재 노드를 u라 했을 때 `dist[v]`와 `dist[u] + length(u, v)`를 비교하여 갱신해주는 것이였다면 prim은 단순히 `dist[v]`와 `length(u, v)`를 비교하여 갱신해주기만 하면 됩니다. 즉, 다익스트라 코드와 정확히 2줄만 다르고 나머지는 전부 동일합니다.

다음 그래프를 예로 프림 알고리즘을 설명해보겠습니다.

![](https://contents.codetree.ai/problems/1020/images/3cf7e7ed-3c35-4487-90ac-75c2fef1aad3.svg)

프림은 시작점을 아무 점이나 잡아도 상관없다고 했습니다. 편의상 5번으로 잡고 시작해보겠습니다.

똑같이 dist 배열을 사용할 것이지만, 이 dist 배열의 정의가 다익스트라에서의 dist 배열과는 아예 다릅니다. `dist[x]`는 **현재까지 만들어진 MST와 노드 x를 연결하기 위해 필요한 최소 비용**입니다. 이 정의를 꼭 기억해주세요.

이제 다익스트라 알고리즘에서처럼 dist 배열을 초기화해주고 시작해보려 합니다. dist 배열을 전부 아주 큰 값(INF)으로 초기화하고, 출발지의 값만 0으로 설정하게 됩니다. 시작점만 0으로 설정해주는 까닭은, 처음 해당 노드가 선택되어야만 MST를 만드는 것을 시작할 수 있기 때문입니다.

![](https://contents.codetree.ai/problems/1020/images/5f83cace-4f3f-49de-b4ba-8e16dbc88d93.svg)

이제 거리 dist 내의 값들 중 최솟값을 골라줍니다. 이렇게 최솟값을 골라주는 과정을 프림 알고리즘에서도 역시 여러 번 반복하게 되므로 우선순위 큐를 사용합니다. 따라서 우리는 처음 시작할 때부터 1번부터 5번 정점까지 전부 우선순위 큐에 넣어 거리 값 중 최솟값을 골라줄 수 있도록 합니다.

![](https://contents.codetree.ai/problems/1020/images/7e4b47bc-cf39-4e67-9dd8-60a3dd4ad708.svg)

처음 거리가 최솟값인 노드를 고르면 5번 노드가 선택됩니다. 이렇게 프림 알고리즘에서 최솟값이 뽑혔다는 의미는, 해당 노드를 MST에 추가하겠다는 뜻입니다. 이때 우선순위 큐에서 5번 노드는 빠지게 됩니다.

![](https://contents.codetree.ai/problems/1020/images/992ba29d-e639-45b2-819c-1fe4d07319b2.svg)

이제 이 5번 노드에 연결된 노드들을 보며 간선에 적혀있는 값과 해당 노드에 적혀있는 dist값과 비교하여 더 작은 값으로 갱신해줍니다. 이 의미는, 현재 MST를 이루고 있는 노드가 5번 노드이므로 5번 노드에 추가적으로 연결할 수 있는 정점들에 대해 각 정점을 간선을 통해 추가했을 때 추가적으로 나가게 되는 비용을 갱신해주는 것입니다.

![](https://contents.codetree.ai/problems/1020/images/d739e3f8-621f-4cdc-8b9c-77ef4486e56c.svg)

이 과정을 거치면 `dist[2]`는 아주 큰 값인 INF였으므로 `length(5, 2)`에 해당하는 값 4로 바뀌게 되며, `dist[4]` 역시 아주 큰 값인 INF였으므로 `length(5, 4)`에 해당하는 값 2로 바뀌게 됩니다.

![](https://contents.codetree.ai/problems/1020/images/55262de0-41c0-4ce9-95f0-140764765302.svg)

그 다음 우선순위 큐에 담겨있는 노드들 중 dist 최솟값을 갖고 있는 노드를 고르게 되면, `dist[4]`값이 2 이므로 4번 노드가 골라지게 됩니다. 이때 이 의미에 주목해야 합니다. 이는 현재 MST에 4번 노드를 추가하는게 가장 좋은 상황이었다는 뜻으로, 이때 비용이 2만큼 든다는 뜻입니다. 따라서 다음과 같이 4번 노드가 뽑힘과 동시에 MST에 4-5를 연결하는 간선이 추가됩니다.

![](https://contents.codetree.ai/problems/1020/images/b2f28d9e-9c50-49e4-801e-24d389d484b2.svg)

4번 노드에 대해서도 연결된 간선들을 보며 최솟값으로 갱신해주는 작업을 거치게 됩니다.

![](https://contents.codetree.ai/problems/1020/images/b04472ce-672e-41bf-b1be-879a5bec8a87.svg)

이 과정을 거치면 `dist[1]`은 아주 큰 값인 INF였으므로 `length(4, 1)`에 해당하는 값 3으로 바뀌게 되며, `dist[2]`의 경우 원래 값이 4였지만, `length(4, 2)`가 1로 더 작기 때문에 값이 1으로 바뀌게 됩니다. 또, `dist[3]`의 경우 아주 큰 값인 INF였으므로 `length(4, 3)`에 해당하는 값 2로 바뀌게 됩니다. 이 의미는 MST가 현재 노드 4, 5로 구성되어져 있는데 이들과 연결되기 위해 1번 노드는 비용 3이 필요하고, 2번 노드는 비용 1이 필요하고, 3번 노드는 비용 2가 필요하다는 뜻입니다.

![](https://contents.codetree.ai/problems/1020/images/6cc39dc4-63f5-4ba4-9114-3d0f91dd5804.svg)

이때 4번 노드에 대해서만 갱신을 진행해도 되는 이유는 바로 다음과 같습니다.

현재 완성되어있는 MST는 다음과 같이 4-5로만 이루어져 있습니다.

![](https://contents.codetree.ai/problems/1020/images/514c9a66-beed-4c39-bbb0-58a3706daddf.svg)

저희가 여기서 하고 싶은 것은 **현재 MST에 특정 간선을 새로 추가하여 새로운 정점을 하나 붙이고 싶은 것입니다.** 즉, 남은 정점에 대해 정점 4 혹은 정점 5에 연결하기 위해 필요한 최소 가중치의 간선 값을 구해야 합니다.

이때, 저희는 이미 정점 5에 대해서는 다음과 같이 5번에 새로 간선을 연결 했을 때의 최소 비용을 dist 배열에 적어줬습니다.

![](https://contents.codetree.ai/problems/1020/images/e90abe0c-db24-43c6-9ec2-51dd9ba8d119.svg)

따라서 4번 정점이 추가된 이후에는, 이제 4번 정점에 새로 간선을 연결 했을 때의 최소 비용을 dist 배열에 갱신해주면, dist 배열은 정점 4, 5 둘 중 하나에 연결하기 위해 필요한 최소 비용이 될 것입니다.

![](https://contents.codetree.ai/problems/1020/images/7b13dae2-03ec-4529-aa34-a770f61b90d2.svg)

그렇기에 이러한 과정을 모든 지점이 선택될 때까지 계속 반복하면, 최종적으로 dist 배열에 적혀있는 값들이 각 정점을 MST에 추가하기 위해 필요했던 최소 비용이 됩니다.

![](https://contents.codetree.ai/problems/1020/images/6e0eeb73-489a-47f8-9989-cbcaf8160975.svg)

그래프 내의 정점의 수를 |V|, 간선의 수를 |E|라 했을 때 이 알고리즘의 시간복잡도는 다익스트라와 마찬가지로 O(∣E∣log∣V∣)가 됩니다. 그 이유는 프림 알고리즘을 진행하면 각 간선을 한 번씩 보게 되는데, 이때 dist값이 변하면 우선순위큐에서의 순서가 계속 바뀌게 될 수도 있으므로 간선의 수 × 우선순위 큐 이용 시간복잡도가 됩니다.

만약 우선순위 큐를 이용하지 않고, for 문을 이용해 최솟값을 찾는 식으로 코드를 구현한다면, 최솟값에 해당하는 노드를 고르는데 |V|번 시간이 소요되고 이 과정을 총 |V|번 반복해야 모든 노드를 선택하게 되므로 시간복잡도는 O(∣V∣2)이 될 것입니다.

프림 코드를 살펴보면 다음과 같습니다.
```jsx
function prim(graph)                          // 그래프와 시작점 정보가 주어집니다.
    set Q = Queue()                           // 우선순위 큐를 만들어줍니다.

    for each vertex in graph                  // 그래프에 있는 모든 노드들에 대해
        set dist[v] = INF                     // 초기값을 전부 아주 큰 값으로 설정해주고 
        Q.push(v)                             // 우선순위큐에 각 노드를 넣어줍니다.
    set source = |V|                          // 시작점을 임의로 마지막 노드로 설정합니다.
    set dist[source] = 0                      // 시작점 대해서만 dist 값을 0으로 초기화해줍니다.
    while Q is not empty                      // 우선순위 큐가 비어있지 않을 때까지 반복합니다.
        set u = vertex in Q with min dist     // 우선순위 큐에서 dist값이 가장 작은 노드를 선택합니다.
        Q.remove(u)                           // 우선순위 큐에서 해당 노드를 제거해줍니다.

        for each neighbor v of u              // u번 노드와 연결된 노드들을 전부 살펴보면서
            set alt = length(u, v)            // 간선 가중치를 살펴봅니다.
            if alt < dist[v]                  // 기존 dist값보다 더 alt값이 작다면
                set dist[v] = alt             // dist값을 갱신해줍니다.
```
##### Topological Sort(위상정렬)

다음과 같이 방향성 그래프가 주어져 있고, 각 노드가 하나의 일 이라고 생각해봅시다. 앞에 일이 끝나야만 뒤에 일이 진행될 수 있는 문제라면, 어떤 순서대로 작업을 진행해야 할까요?

![img|600](https://contents.codetree.ai/problems/1024/images/62f1435b-6f19-4473-afc4-8b958715f9e1.png)

예를 들어 위 그래프에서 가능한 순서중에 하나는 `1, 3, 4, 6, 2, 5, 7`입니다. `1, 4, 3, 6, 2, 5, 7`도 가능하므로 가능한 순서가 유일하다고는 말할 수 없습니다.

이렇게 가능한 순서들 중 하나를 뽑아주는 방법을 위상정렬이라 부릅니다. 위상정렬 방법에는 크게 dfs를 이용한 방법, in-degree를 이용한 방법 이렇게 2가지가 있습니다.

먼저 dfs를 이용한 방법부터 알아보도록 하겠습니다. 결론부터 얘기해보자면, dfs로 탐색을 진행하다가 더 이상 진행할 수 없는 노드가 되었을 때 그 순서를 기록하게 되면, 위상정렬은 그 순서의 역순이 답이 됩니다. 따라서 이는 stack을 이용하여 편하게 구현할 수 있습니다.

한 노드에서 갈 수 있는 정점이 여러 개라면, 작은 번호부터 방문한다고 가정하고 진행과정을 살펴보도록 하겠습니다. dfs 진행 중 퇴각하게 될 시 stack에 넣어주게 되고, 모든 탐색이 진행된 이후에는 stack에서 순서대로 값을 빼내어 적어준 순서가 바로 위상정렬 순서가 됩니다.

위와 같은 그래프에서 번호가 다음과 같이 주어져 있는 경우라면 어떻게 될까요?

![img|600](https://contents.codetree.ai/problems/1024/images/26704e00-5d18-49c3-93a7-2debb4ce1ecf.png)

dfs 탐색을 1번부터 시작한다면 다음과 같이 1, 5, 7에 대한 순서만 정해지고 탐색이 종료되고 말 것입니다.

그렇다면 다시 2번 정점에서 시작하여 남은 정점들에 대해 동일한 과정을 진행해줘야 합니다.

이처럼 dfs를 이용한 위상정렬에서 가장 중요한 점은, **1번 정점부터 n번 정점까지 순서대로 보면서 아직 방문한 적이 없는 정점에 대해서는 전부 해당 정점을 시작점으로 하여 dfs를 추가적으로 진행해줘야만 한다는 것입니다.**

dfs를 이용한 위상정렬 진행시 각 정점과 각 간선을 한 번씩 보게 되기에 시간복잡도는 O(V+E)가 됩니다.

그 다음으로는 in-degree를 이용한 방법을 알아보겠습니다. in-degree란 정점마다 해당 정점으로 들어오는 간선의 수를 의미합니다. 예를 들어, 다음 그래프에서 각 노드마다의 in-degree를 표시해보면 다음과 같습니다.

![img|600](https://contents.codetree.ai/problems/1024/images/d48a031a-b890-4582-836d-330c8a4ad35b.png)

위상정렬이라는 것은 곧 앞에 처리해야 할 순서가 끝나고 난 뒤에 현재 일을 처리하면 되는 것이기 때문에, **in-degree가 0**인 지점이 항상 시작점이라고 얘기할 수 있다는 것이 핵심입니다. 이때, in-degree를 이용한 위상정렬 방법에서 역시 한 노드에서 갈 수 있는 정점이 여러 개라면, 작은 번호부터 확인한다고 가정하고 진행과정을 살펴보도록 하겠습니다.

위의 그래프에서 in-degree가 0인 지점을 전부 queue에 넣고 시작합니다. 이 그래프에서는 1번 정점만이 처음 in-degree 값이 0이므로 1번 정점을 queue에 넣어주게 됩니다.

![img|600](https://contents.codetree.ai/problems/1024/images/a6cb9e69-32ba-4a71-96bf-4e6fc3be6f6d.png)

이제 queue에서 가장 앞에 있는 값을 뽑아, 해당 정점에 연결되어 있는 모든 간선을 살펴봅니다. 이때, 해당 간선이 가리키는 곳에 있는 정점의 in-degree를 1 감소시켜줍니다.

![img|600](https://contents.codetree.ai/problems/1024/images/7edb04fe-d8b1-41f0-bd11-0e5cb4997fa8.png)

간선을 직접 지워주지는 않지만, in-degree를 1만큼 감소시켜줬으므로 의미상 해당 간선은 지워진 것과 다름 없습니다.

![img|600](https://contents.codetree.ai/problems/1024/images/da984d49-8cfb-435b-9ee3-21e1d786eaa6.png)

그 다음 1과 3일 잇는 간선 때문에 노드 3의 in-degree는 0이 됩니다. 이렇게 in-degree가 0이 된 순간에는 해당 노드를 바로 queue로 삽입해줍니다.

노드 1에 대해서 연결된 간선을 전부 살펴보면 다음과 같이 됩니다.

![img|600](https://contents.codetree.ai/problems/1024/images/51da675c-5785-48f8-9e86-7149318532d5.png)

이제 큐가 비어지기 전까지 계속 과정을 반복하면 됩니다. 이러한 과정을 반복하며 큐에서 나온 그 순서가 바로 위상정렬 순서가 됩니다.

다음과 같이 in-degree가 0인 지점이 여러 개인 경우에도, 처음 queue에 여러 노드를 넣고 시작하는 것만 다를 뿐 다른 과정은 전부 동일합니다.

![img|600](https://contents.codetree.ai/problems/1024/images/a6396c78-34a6-4c2b-be86-8ec8e8d93555.png)

in-degree를 이용한 위상정렬 방법 역시 각 정점과 각 간선을 한 번씩 보게 되기에 시간복잡도는 O(V+E)가 됩니다.

무방향 그래프에서는 순서가 정의되지 않다보니 위상정렬 알고리즘을 적용하기가 어렵습니다. 또, 다음과 같이 사이클을 이루고 있는 경우 역시 순서를 정의할 수 없기 때문에 위상정렬을 적용할 수 없습니다.

![img|600](https://contents.codetree.ai/problems/1024/images/deabf5dc-3c05-425e-9910-8a923d1e8751.png)

또한, 여러 개의 그래프로 나뉘어져 있는 경우에서 역시 위상정렬이 올바르게 정의됩니다. 이 경우 역시 dfs를 이용한 위상정렬과, in-degree를 이용한 위상정렬 방법이 모두 가능합니다.
#### 문제
- 더하기 구현
```C++
string Add(string str1, string str2)
{
    int str1Idx = str1.length() - 1;
    int str2Idx = str2.length() - 1;

    string result;
    int carry = 0;
    while(carry != 0 || str1Idx > -1 || str2Idx > -1) {
        int sum = carry; 

        if(str1Idx > -1) {
            sum += str1[str1Idx] - '0';
        }

        if(str2Idx > -1) {
            sum += str2[str2Idx] - '0';
        }

        result += char(sum % 10 + '0');
        carry = sum / 10;

        str1Idx--;
        str2Idx--;
    }

    reverse(result.begin(), result.end());

	return result;
}
```
- 빼기
```C++
// 항상 큰 수에서 작은 수를 빼는 경우(결과가 음수가 되지 않는 경우)를 가정
string Subtract(string str1, string str2)
{
	if (str1 == str2)
		return "0";

	int N = max(str1.size(), str2.size());
	str1 = string(N - str1.size(), '0') + str1;
	str2 = string(N - str2.size(), '0') + str2;

	string result(N, '0');

    for(int i = N - 1; i > -1; i--) {
        int u = str1[i] - '0';
        int d = str2[i] - '0';

        if(u < d && i > 0) {
            str1[i - 1]--;
            u += 10;
        }

        result[i] = u - d + '0';
    }
    
    int zeroC = 0;
    for(char c : result) {
        if(c != '0') break;
        zeroC++;
    }

	return result.substr(zeroC);
}
```
- 곱하기
```C++
string Multiply(string str1, string str2)
{
	string result;
    
    if(str1.length() < str2.length())
        swap(str1, str2);
    
    int offset = 0;
    for(int i = str2.length() - 1; i > -1; i--) {
        int d = str2[i] - '0';
        int carry = 0;
        int resultIdx = (result.length() - 1) - offset;
        for(int j = str1.length() - 1; j > -1; j--) {
            int u = str1[j] - '0';
            int n = u * d + carry;

            if(resultIdx > -1) {
                n += result[resultIdx] - '0';
                result[resultIdx] = n % 10 + '0';
            } else {
                result = char(n % 10 + '0') + result;
            }

            carry = n / 10;
            resultIdx--;
        }

        if(carry != 0) {
            result = char(carry + '0') + result;
        }

        offset++;
    }

	return result;
}
```
- Karatuba 곱하기 알고리즘 [info](https://hhlab.tistory.com/11)
```C++
string Karatsuba(string str1, string str2) {
    if(str1.size() == 1 && str2.size() == 1) {
        return to_string((str1[0] - '0') * (str2[0] - '0')); 
    }

    if(str1.size() < str2.size())
        str1 = string(str2.size() - str1.size(), '0') + str1;
    else if(str1.size() > str2.size())
        str2 = string(str1.size() - str2.size(), '0') + str2;
        
    int mid = str1.size() / 2;

    string a = str1.substr(0, mid);
    string b = str1.substr(mid);
    string c = str2.substr(0, mid);
    string d = str2.substr(mid);

    string ac = Karatsuba(a, c);
    string bd = Karatsuba(b, d);
    string ab_cd = Karatsuba(Add(a, b), Add(c, d));

    int zc = str1.size() - a.size();
    string t = Subtract(ab_cd, Add(ac, bd));
    t.append(zc, '0');

    if(ac[0] != '0')
        ac.append(2 * zc, '0');

    return Add(Add(ac, t), bd);
}
```
- Insertion sort
```C++
void InsertionSort(std::vector<int> v) {
	for(int i = 1; i < v.size(); i++) {
        for(int j = i; j > 0; j--) {
            if(v[j] < v[j-1]) {
                std::swap(v[j], v[j-1]);
            } else {
                break;
            }
        }
    }
}
```
- Merge sort
```C++
vector<int> aux; // 추가 메모리 필요

//Top-Down
void Merge(vector<int>& a, int lo, int mid, int hi) {
	int i = lo, j = mid + 1;

	for (int k = lo; k <= hi; k++)
		aux[k] = a[k];

	for (int k = lo; k <= hi; k++)
	{
	   if(i > mid) a[k] = aux[j++];
	   else if (j > hi) a[k] = aux[i++];
	   else if (aux[i] < aux[j]) a[k] = aux[i++];
	   else a[k] = aux[j++];
	}
}

void SortHelper(vector<int>& a, int lo, int hi)
{
	if (hi <= lo) return;
	int mid = lo + (hi - lo) / 2;
	SortHelper(a, lo, mid);
	SortHelper(a, mid + 1, hi);
	Merge(a, lo, mid, hi);
}

//Bottom-Up
void Sort(vector<int>& a)
{
	aux.resize(a.size());

	int N = a.size();
	int lv = 1;

	while(lv < N) {
		lv *= 2;

		for(int j = 0; j < N; j += lv) {
			int low = j;
			int hi = j + lv - 1;
			int mid = low + (hi - low) / 2;
			hi = min(hi, N - 1);
			Merge(a, low, mid, hi);
		}
	}
}

void Merge(vector<int>& a, int lo, int mid, int hi)
{
	for(int i = lo; i <= hi; i++) {
		aux[i] = a[i];
	}

	int l = lo, r = mid + 1;
	for(int i = lo; i <= hi; i++) {
		if(l > mid) a[i] = aux[r++];
		else if(r > hi) a[i] = aux[l++];
		else if(aux[l] < aux[r]) a[i] = aux[l++];
		else a[i] = aux[r++];
	}
}
```
- 같은 숫자 갯수
```C++
int Count1(const vector<int>& arr, int x)
{
	//TODO: O(n)
	int result = 0;
	for(int v : arr) {
		if(v == x) 
			result++;
	}
	return result;
}

int Count2(const vector<int>& arr, int x)
{
	//TODO: O(log(n) + count)
	int l = 0, r = arr.size() - 1;
	while(l < r) {
		int mid = l + ((r - l) >> 1);

		if(arr[mid] >= x) r = mid;
		else if(arr[mid] < x) l = mid + 1;
	}

	int result = 0;
	for(int i = l; i < arr.size(); i++) {
		if(arr[i] > x) break;
		result++;
	}
	return result;
}

int Count3(const vector<int>& arr, int x)
{
	//TODO: O(log(n))
	int first = 0, last = arr.size() - 1;

	int l = 0, r = arr.size() - 1;
	while(l <= r) {
		int mid = l + ((r - l) >> 1);
		if(arr[mid] > x) r = mid - 1;
		else if(arr[mid] < x) l = mid + 1;
		else if(mid > 0 && arr[mid - 1] == x) r = mid - 1;
		else {
			l = mid;
			break;
		}
	}

	first = l;

	l = 0, r = arr.size() - 1;
	while(l <= r) {
		int mid = l + ((r - l) >> 1);
		if(arr[mid] > x) r = mid - 1;
		else if(arr[mid] < x) l = mid + 1;
		else if(mid < arr.size() - 1 && arr[mid + 1] == x) l = mid + 1;
		else {
			r = mid;
			break;
		}
	}

	last = r;

	return max(0, last - first + 1);
}
```
- 부분 선택 정렬
```C++
void SelectionSortPass(vector<int>& arr, int lo, int hi)
{
	int minIdx = lo;
	for(int i = lo + 1; i <= hi; i++) {
		if(arr[minIdx] > arr[i]) {
			minIdx = i;
		}
	}
	swap(arr[minIdx], arr[lo]);
}

void PartialSelectionSort(vector<int>& arr, int k)
{
	for (int i = 0; i < k; i++)
	{
		SelectionSortPass(arr, i, arr.size() - 1);
	}
}
```
- 짝수 갯수의 배열 최대, 최소 구하기
```C++
int main()
{
	vector<int> arr = { 8, 2, 3, 5, 9, 1, 9, 4, 3, 7, 6, 7 };

	if(arr[0] > arr[1]) {
		swap(arr[0], arr[1]);
	}

	for(int i = 2; i < arr.size(); i += 2) {
		int mi = arr[i];
		int ma = arr[i + 1];

		if(mi > ma) {
			mi = arr[i + 1];
			ma = arr[i];
		}

		arr[0] = min(arr[0], mi);
		arr[1] = max(arr[1], ma);
	}
}
```
- 기준값에 의한 분할
```C++
int main()
{
	vector<int> arr = { 5, 2, 7, 3, 8, 5, 6, 4 };
	//vector<int> arr = { 2, 8, 7, 1, 3, 5, 6, 4 };
	//vector<int> arr = { 9, 8, 7, 6, 4, 3, 2, 1, 5 };
	//vector<int> arr = { 5, 2, 7, 3, 4, 4, 6, 4 };

	int lo = 0;  // 첫 인덱스
	int hi = arr.size() - 1;  // 마지막 인덱스
	int x = arr[hi]; // 분할 기준으로 사용하는 pivot 4

	int i = lo - 1; // pivot보다 것들중 가장 큰 인덱스
	int j = 0;
	for(; j < hi; j++) {
		if(arr[j] <= x) {
			swap(arr[++i], arr[j]);
		}
	}
	swap(arr[i + 1], arr[hi]);
}
```
- n번째로 큰 숫자 찾기
```C++
int Partition(vector<int>& arr, int lo, int hi)
{
	int x = arr[hi]; // 마지막 값을 피벗으로 사용
	int i = lo - 1;
	for (int j = lo; j < hi; j++)
	{
		if (arr[j] <= x)
		{
			i += 1;
			swap(arr[i], arr[j]);
		}
	}

	swap(arr[i + 1], arr[hi]);

	return i + 1; // 피벗이 이동한 위치 반환
}

int RandomizedSelect(vector<int>& arr, int lo, int hi, int k)
{
	if (lo == hi) return arr[lo]; // 하나만 남았을 경우

	int index = Partition(arr, lo, hi); // pivot index

	if (index - lo == k - 1) {
		return arr[index];
	}
	else if (k - 1 < index - lo) {
		return RandomizedSelect(arr, lo, index - 1, k);
	}
	else {
		return RandomizedSelect(arr, index + 1, hi, k - (index - lo + 1));
	}

	return -1;
}
```
- 최대 공약수
```C++
int gcd(int a, int b) {
	while(b) {
		int tmp = a % b;
		a = b;
		b = tmp;
	}
	return a;
}

int gcd(int a, int b) { return a % b ? gcd(b, a % b) : b; }
```
- 최소 공배수
```C++
int lcm(int a, int b) {
	return (a * b) / gcd(a, b);
}
```
- 배열 회전
```C++
void rotate(vector<int>& vec) {
	int carry = vec.back();
	for(int i = 0; i < vec.size(); i++) swap(vec[i], carry);
}
```
- 이분 탐색
```C++
bool bfind(vector<int> vec, int v) {
	sort(vec.begin(), vec.end());
	int l = 0, r = vec.size() - 1;
	while(l <= r) {
		int mid = l + (r - l) / 2;
		if(vec[mid] == v) return true;
		else if(vec[mid] < v) l = mid + 1;
		else r = mid - 1;
	}
	return false;
}
```
- 2차원 배열 회전
```cpp
void rotate(vector<vector<int>>& matrix) {
	int n = matrix.size();
	//상하 반전
	for (int i = 0; i < n / 2; ++i) {
		for (int j = 0; j < n; ++j) {
			swap(matrix[i][j], matrix[n - i - 1][j]);
		}
	}
	//대각선 기준 반전
	for (int i = 0; i < n; ++i) {
		for (int j = i + 1; j < n; ++j) {
			swap(matrix[i][j], matrix[j][i]);
		}
	}
}

void rotate(vector<vector<int>>& matrix) {
	int n = matrix.size();
	//대각선 반전
	for(int i = 0; i < n; i++) {
		for(int j = i; j < n; j++) {
			swap(matrix[i][j], matrix[j][i]);
		}
	}
	//가로 반전
	for(int i = 0; i < n; i++) {
		reverse(matrix[i].begin(), matrix[i].end());
	}
}

//초기 본인 코드
void rotate(vector<vector<int>>& mat, int a, int b) {
	if(a >= b) return;

	int cnt = b - a;
	while(cnt--) {
		int carry = mat[a][a];
		for(int i = a; i < b; i++) swap(mat[a][i], carry);
		for(int i = a; i < b; i++) swap(mat[i][b], carry);
		for(int i = b; i > a; i--) swap(mat[b][i], carry);
		for(int i = b; i > a; i--) swap(mat[i][a], carry);
		mat[a][a] = carry;
	}

	rotate(mat, a + 1, b - 1);
}

void rotate(vector<vector<int>>& matrix) {
	rotate(matrix, 0, matrix.size() - 1);
}
```
- lower bound, upper bound
```C++
int lower_bound(vector<int>& arr, int v) {
	int l = 0, r = arr.size();
	while(l < r) {
		int mid = (l + r) / 2;
		if(arr[mid] >= v) {
			r = mid;
		} else {
			l = mid + 1;
		}
	}
	return r;
}

int upper_bound(vector<int>& arr, int v) {
	int l = 0, r = arr.size();
	while(l < r) {
		int mid = (l + r) / 2;
		if(arr[mid] <= v) {
			l = mid + 1;
		} else {	
			r = mid;
		}
	}
	return r;
}
```
- 에라토스테네스 체
```C++
bool era[1000000];
void eratos(int n) {
	fill(era, era + n + 1, true);
	era[0] = era[1] = false;
	for(int i = 2; i * i <= n; i++) {
		if(era[i]) {
			for(int j = i * i; j <= n; j += i) {
				era[j] = false;
			}
		}
	}
}
```
- 세그먼트 트리
```cpp
int make_seg_tree(vector<int>& vec, vector<int>& tree, int node, int start, int end) {
	if(start == end) return tree[node] = vec[start];
	int mid = (start + end) / 2;
	return tree[node] = make_seg_tree(vec, tree, node * 2, start, mid) + make_seg_tree(vec, tree, node * 2 + 1, mid + 1, end);
}

int get_sum(vector<int>& seg_tree, int node, int start, int end, int left, int right) {
	if(left > end || right < start) return 0;
	if(left <= start && right >= end) return seg_tree[node];
	int mid = (start + end) / 2;
	return get_sum(seg_tree, node * 2, start, mid, left, right) + get_sum(seg_tree, node * 2 + 1, mid + 1, end, left, right);
}

void update_seg_tree(vector<int>& seg_tree, int node, int start, int end, int idx, int diff) {
	if(idx < start || idx > end) return;
	seg_tree[node] += diff;
	if(start != end) {
		int mid = (start + end) / 2;
		update_seg_tree(seg_tree, node * 2, start, mid, idx, diff);
		update_seg_tree(seg_tree, node * 2 + 1, mid + 1, end, idx, diff);
	}
}

int main() {
	vector<int> vec = {1, 2, 3, 4, 5};

	int n = vec.size();
	int lv = ceil(log2(n));
	int sz = 1 << (lv + 1);

	vector<int> tree(sz, 0);
	make_seg_tree(vec, tree, 1, 0, n - 1);
	
	cout << get_sum(tree, 1, 0, n - 1, 0, 0) << '\n';
	cout << get_sum(tree, 1, 0, n - 1, 0, 1) << '\n';
	cout << get_sum(tree, 1, 0, n - 1, 1, 3) << '\n';
	
	update_seg_tree(tree, 1, 0, n - 1, 1, 3 - vec[1]);
	vec[1] = 3;
	cout << get_sum(tree, 1, 0, n - 1, 0, 2) << '\n';
	
	return 0;
}
```
- 펜윅 트리
```cpp
void update(vector<int>& tree, int idx, int v) {
	while(idx < tree.size()) {
		tree[idx] += v;
		idx = idx + (idx & -idx);
	}
}

void make_tree(vector<int>& arr, vector<int>& tree) {
	tree.resize(arr.size() + 1, 0);
	for(int i = 1; i < tree.size(); i++) {
		update(tree, i, arr[i - 1]);
	}
}

int get_sum(vector<int>& tree, int idx) {
	int ret = 0;
	while(idx > 0) {
		ret += tree[idx];
		idx = idx - (idx & -idx);
	}
	return ret;
}

int main() {
	vector<int> arr = {1, 2, 3, 4, 5, 6, 7};
	vector<int> tree;
	make_tree(arr, tree);
	// get sum 1 to 4
	cout << get_sum(tree, 4) << '\n';
	// get sum 3 to 5
	cout << get_sum(tree, 5) - get_sum(tree, 2) << '\n';

	return 0;
}
```
- union_find
```cpp
int get_parent(int* parent, int v) {
	if(parent[v] == v) return v;
	return parent[v] = get_parent(parent, parent[v]);
}

void union_parent(int* parent, int a, int b) {
	int ap = get_parent(parent, a), bp = get_parent(parent, b);
	if(ap < bp) parent[b] = ap;
	else parent[a]= bp;
}

bool find_parent(int* parent, int a, int b) {
	return get_parent(parent, a) == get_parent(parent, b);
}

int main() {
	int parent[10];
	for(int i = 0; i < 10; i++) {
		parent[i] = i;
	}

	union_parent(parent, 0, 1);
	union_parent(parent, 1, 2);
	union_parent(parent, 8, 9);

	cout << "0,1 is same parent? ans : " << find_parent(parent, 0, 1) << '\n';
	cout << "0,5 is same parent? ans : " << find_parent(parent, 0, 5) << '\n';
	
	union_parent(parent, 2, 5);
	cout << "0,5 is same parent? ans : " << find_parent(parent, 0, 5) << '\n';

	return 0;
}
``` 
- 부분 수열의 합이 m
```cpp
/*
n개의 원소로 이루어진 수열 A가 주어졌을 때, 수열 A의 부분 수열 내 원소의 합이 m이 되는 경우 중 가능한 최소 수열의 길이를 구하는 프로그램을 작성해보세요. 수열의 길이란, 수열 내 원소의 개수를 의미합니다.

ans) dp문제로 해결 가능. 동전을 하나씩만 사용하여 원하는 금액을 만들 수 있는 최소 동전의 개수를 구하는 문제와 유사
*/
int main() {
	int n, m;
	cin >> n >> m;
	int arr[100];
	for(int i = 0; i < n; i++) {
		cin >> arr[i];
	}
	int dp[10001];
	fill(dp, dp + 10001, MAX);
	dp[0] = 0;
	for(int i = 0; i < n; i++) {
		int kind = arr[i];
		for(int j = m; j > 0; j--) {
			if(j - kind >= 0) {
				dp[j] = min(dp[j], dp[j - kind] + 1);
			}
		}
	}
	cout << (dp[m] != MAX ? dp[m] : -1);
	return 0;
}
```
