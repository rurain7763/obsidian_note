#### C++
##### 가상 함수 테이블과 virtual에 대해 설명하시오.
`virtual` 키워드는 C++에서 다형성을 구현하기 위한 도구로, 부모 클래스의 포인터나 참조를 사용해 자식 클래스의 동작을 런타임에 호출할 수 있도록 해줍니다.

가상 함수가 포함된 클래스는 가상 함수 테이블(vtable)이라는 구조를 생성합니다. vtable은 해당 클래스의 가상 함수들의 주소를 저장한 테이블입니다. 각 객체는 해당 클래스의 vtable을 가리키는 포인터(vptr)를 유지합니다. 가상 함수를 호출할 때는 vptr을 통해 vtable을 참조하고, 테이블에 저장된 함수 주소를 사용하여 런타임에 올바른 함수를 호출합니다. 단점으로는 일반 함수 호출보다 느리며, 메모리 오버헤드가 발생합니다.
##### 상속과 오버라이딩에 대해 설명하시오.
**상속이란** 기존 클래스(부모 클래스)의 **멤버 변수와 메서드**를 자식 클래스가 물려받아 사용할 수 있도록 하여 **코드 재사용성과 확장성**을 높이는 객체지향 프로그래밍의 중요한 특징 중 하나입니다. 상속은 **"is-a" 관계**를 나타내며, 예를 들어, "강아지는 동물이다"라는 관계에서 동물은 부모 클래스, 강아지는 자식 클래스가 됩니다. 부모 클래스의 멤버를 그대로 사용할 수도 있고, 자식 클래스에서 추가하거나 수정할 수도 있습니다.

**오버라이딩이란** 부모 클래스에서 `virtual` 키워드로 정의한 **가상 함수**를 자식 클래스가 재정의하여 사용하는 것을 말합니다. 이를 통해 부모와 자식 클래스가 동일한 함수 호출에 대해 서로 다른 동작을 구현할 수 있습니다.

**오버로딩**과 **오버라이딩**은 종종 혼동되지만, 다음과 같은 차이가 있습니다
**오버로딩**은 함수 이름은 같지만 매개변수의 개수나 타입이 다른 함수를 정의하여 **컴파일타임 다형성**을 구현합니다.
**오버라이딩**은 부모 클래스의 가상 함수를 자식 클래스에서 재정의하며, **런타임 다형성**을 구현합니다.
##### 스마트 포인터와 RAII에 대해 설명하시오.
RAII(Resource Acquisition Is Initialization)는 생성자와 소멸자를 활용한 디자인 패턴으로, 자원의 할당과 해제를 자동으로 처리하여 메모리 누수와 자원 누출을 방지하는 기법입니다. RAII는 C++의 강력한 기능 중 하나로, 객체의 생성자에서 자원을 할당하고, 소멸자에서 자원을 해제하여 자원 관리를 자동화합니다.

스마트 포인터란 RAII를 활용한 자원 관리 클래스로, GC가 없는 C++의 환경에서 동적 메모리 관리를 자동화하는데 사용됩니다. 대표적으로 `std::unique_ptr`, `std::shared_ptr`, `std::weak_ptr`가 있습니다.

- `std::unique_ptr`: 한 객체만 소유하며 소유권을 이전할 수 있습니다. 복사는 불가능하며, 소유권을 이전할 때는 `std::move()`를 사용합니다.
- `std::shared_ptr`: 여러 객체가 소유할 수 있으며 참조 횟수를 관리합니다. 참조 횟수가 0이 되면 자동으로 메모리를 해제합니다.
- `std::weak_ptr`: `std::shared_ptr`의 순환 참조 문제를 해결하기 위한 포인터로, 참조 카운터를 증가시키지 않고 참조만 가능합니다.
##### 스택과 힙 메모리의 차이점에 대해 설명하시오.
스택 메모리란 지역 변수, 함수 매개 변수, 함수 호출등의 정보를 저장하는 컴파일러 관리 메모리 영역입니다. 스택은 LIFO(Last In First Out) 방식으로 동작하며, 함수 호출 시 함수의 매개변수, 지역 변수, 복귀 주소 등이 스택 프레임에 저장됩니다. 스택 프레임은 함수 호출 시 생성되고 함수 종료 시 소멸됩니다. 힙 메모리는 동적 할당을 위한 메모리 영역으로, 프로그래머가 직접 메모리를 할당하고 해제해야 합니다. 힙 메모리는 메모리의 할당과 해제가 빈번하게 일어나는 경우에 사용되며, 메모리 누수와 해제되지 않은 메모리를 방지하기 위해 주의가 필요합니다. 스택 메모리는 힙 메모리보다 빠르지만 고정 크기이며, 정적 할당만 가능합니다. 힙 메모리는 크기가 상대적으로 크지만 느리며, 메모리 단편화가 발생할 수 있습니다.
##### 동적 할당이란 무엇이며, 왜 사용하는가?
동적 할당이란 프로그래머가 힙 메모리 영역에 메모리를 할당하는 것을 말합니다. `new` 키워드 및 `malloc()` 함수를 사용하여 메모리를 할당하고, `delete` 키워드 및 `free()` 함수를 사용하여 메모리를 해제합니다. 동적 할당은 프로그램 실행 중에 메모리를 동적으로 할당하고 해제할 수 있어, 메모리의 크기를 미리 알 수 없는 경우에 유용하게 사용됩니다.
##### Struct와 Class의 차이점은 무엇인가?
struct란 기본 접근 지정자가 public이며 class는 private입니다. 또한 상속 시 struct의 경우 public 상속이 기본이며, class는 private 상속이 기본입니다. 기본적인 기능은 차이가 없지만 보통 struct의 경우 데이터 구조를 표현하는데 사용하고, class는 데이터와 함수를 함께 사용하는 용도로 사용합니다.
##### 포인터와 배열의 차이점은 무엇인가?
배열 또한 연속된 데이터의 처음 시작 주소를 가르키는 포인터라고 할 수 있지만, 배열로써 선언된 변수는 포인터에서 가능한 증감, 대입 연산이 불가능합니다. 또한 배열의 경우 크기가 저장된 요소의 크기에 의해 결정되지만, 포인터의 경우 시스템에 따라 32비트 또는 64비트로 결정됩니다.
##### Malloc과 New의 차이점은 무엇인가?
`malloc()` 함수는 C언어에서 사용되는 메모리 할당 함수이고, `new` 키워드는 C++에서 사용되는 메모리 할당 연산자입니다. `malloc()` 함수는 메모리 할당 시 할당할 메모리의 크기를 바이트 단위로 지정해야 하며, 할당된 메모리는 초기화되지 않습니다. `new` 연산자는 클래스의 생성자를 호출하여 메모리를 초기화합니다. 또한 `new` 연산자는 `delete` 연산자를 사용하여 메모리를 해제해야 하지만, `malloc()` 함수는 `free()` 함수를 사용하여 메모리를 해제합니다.
##### Const에 대해 설명하시오.
`const`는 상수을 나타내는 키워드로, 데이터의 수정 가능성을 제한합니다. 이는 코드의 안정성과 가독성을 높이고, 의도치 않은 변경을 방지하는 데 유용합니다.

`const`와 포인터
- `int* const a = ptr;`: 포인터 a는 상수이므로 주소를 변경할 수 없습니다.
- `const int* a = ptr;`: 포인터 a가 가리키는 값은 변경할 수 없습니다.

`const`와 함수 파라미터
- `void foo(const int a)`: 함수 내에서 a의 값을 변경할 수 없습니다.

`const`와 함수 반환값
- `const int foo()`: 함수의 반환값을 상수로 지정합니다.

`const`와 멤버 함수
- `void foo() const`: 멤버 함수 내에서 멤버 변수의 값을 변경할 수 없습니다.
##### Static에 대해 설명하시오.
`static`은 C++에서 다양한 의미로 사용되는 키워드입니다. 기본적으로 변수에 `static` 키워드를 사용할 경우 해당 변수는 프로그램의 시작과 동시에 한번 초기화되며 프로그램이 종료될 때까지 메모리에 data영역에 상주하게 됩니다.

지역 변수에 `static`을 사용한 경우 
- 함수 호출이 끝나도 값이 유지됩니다. 
- 함수 내에서만 접근 가능합니다

전역 변수에 `static`을 사용한 경우
- 해당 파일 내에서만 접근 가능합니다.

멤버 변수에 `static`을 사용한 경우
- 모든 객체가 공유하는 변수가 됩니다.
- 선언 이후 `.cpp`파일에서 초기화를 해주어야 합니다.

멤버 함수에 `static`을 사용한 경우
- 객체를 생성하지 않아도 호출이 가능합니다.
- 멤버 변수 및 함수에 접근할 수 없습니다.
##### 가상 소멸자를 사용하는 이유는 무엇인가?
만약 부모 클래스 포인터를 통해 자식 클래스 객체를 삭제할 때 가상 소멸자를 사용하지 않으면 부모 클래스의 소멸자만이 호출되어 메모리 누수를 야기할 수 있습니다. 따라서 가상 소멸자는 부모 클래스를 통해 자식 클래스를 삭제할 때, 자식 클래스의 소멸자 호출을 보장합니다. 
##### Vector와 List의 차이점은 무엇인가?
vector는 연속된 메모리를 가지는 동적 배열이며 임의 접근이 o(1)에 가능하지만 중간 삭제 및 삽입이 느린 데이터 구조입니다. 메모리 재할당이 발생할 수 있습니다. list는 이중 연결 리스트로 구현되어 비연속적인 메모리를 가지며 임의 접근이 느리지만 중간 삭제 및 삽입이 빠른 데이터 구조입니다. 연속된 메모리를 가지는 vector의 이점은 캐시 적중률이 높아 빠른 값 읽기가 가능하다는 점입니다. 하지만 비연속적인 메모리를 가지는 list는 캐시 미스가 발생할 확률이 높아 성능 저하가 발생할 수 있습니다.
##### Cating에 대해 설명하시오.
캐스팅은 형변환을 의미하며 암묵적 형변환과 명시적 형변환으로 나뉩니다. 암묵적 형변환은 컴파일러가 자동으로 형변환을 수행하는 것이고, 명시적 형변환은 프로그래머가 직접 형변환을 지정하는 것입니다. c++에서는 명식적 캐스팅 연산자는 4가지가 존재합니다.
- `static_cast`: 컴파일 타임에 형변환을 수행하는 캐스팅입니다. c 스타일 캐스팅과 유사합니다.
- `dynamic_cast`: 런타임에 형변환을 수행하는 캐스팅입니다. `virtual`함수를 가진 클래스에서만 사용 가능합니다.
- `const_cast`: const성을 제거 및 부여하는 캐스팅입니다.
- `reinterpret_cast` : 포인터간의 형변환을 수행하는 캐스팅입니다.
##### Template의 장단점은 무엇인가?
다양한 데이터 타입에 대해 동일한 로직을 사용할 수 있어 코드의 재사용성을 높이는 장점이 있습니다. 또한 컴파일 타임에 타입 체크를 수행하여 타입 안정성을 보장합니다. 컴파일 타임에 실제 코드를 생성하기 때문에 런타임에서의 속도는 가상 함수보다 빠르게 동작합니다. 단점으로는 컴파일 시간이 증가하며 파일이 커지게 되어 실행 파일의 용량이 커집니다.
##### typedef와 using에 대해 설명하시오.
`typedef`는 기존의 데이터 타입에 새로운 이름을 지정하는 키워드입니다. `typedef`는 C언어에서 사용되며, C++에서는 C++11에 추가된키워드로 `using`이 동일한 기능을 수행하지만 template를 사용하여 좀 더 유용한 사용이 가능합니다. 둘 다 함수 포인터를 표현할 때나 크로스 플랫폼 코드, 예를 들어 `int32_t`, `int64_t`와 같은 타입을 표현할 때 사용됩니다.
##### 얕은 복사와 깊은 복사에 대해 설명하시오.
얕은 복사는 포인터가 가리키는 주소를 복사하는 것이며, 깊은 복사는 메모리 영역을 새로 할당하고 포인터가 가리키는 주소에 있는 값을 복사하는 것을 말합니다. 복사 생성자 및 대입 연산자에서 발생합니다. 얕은 복사의 경우 인스턴스 소멸 시 이중 해제 오류가 발생할 수 있으며, 깊은 복사의 경우 메모리를 더 많이 사용하게 됩니다.
##### lvalue와 rvalue에 대해 설명하시오.
lvalue는 식이 끝나도 지속되는 객체를 의미합니다. rvalue는 해당 표현식이 끝이나면 사라지는 임시 객체를 의미합니다. lvalue의 경우 `std::move()`를 통해 rvalue로 캐스팅되며 이동 생성자 또는 이동 대입 연산자를 호출하여 복사 오버헤드를 줄일 수 있습니다. 또한 `std::forward()`의 경우 lvalue를 lvalue로써 전달하고, rvalue를 rvalue로써 전달할 수 있습니다.
##### Name Mangling에 대해 설명하시오.
Name Mangling은 함수 이름을 컴파일러가 변경하는 과정을 의미합니다. 함수 오버로딩을 지원하기 위해 사용되며, 함수 이름을 변경하여 컴파일러가 함수를 구분할 수 있도록 합니다. C++에서는 함수 이름에 인자의 타입과 개수를 추가하여 함수 이름을 변경합니다. 따라서 C++코드를 C코드로 컴파일할 때 Name Mangling이 발생하여 C++코드에서는 extern "C"를 사용하여 Name Mangling을 방지합니다.
#### OS
#### 리틀 엔디안과 빅 엔디안에 대해 설명하시오.	
리틀 엔디안은 가장 낮은 자리수부터 메모리에 저장하는 방식이며, 빅 엔디안은 가장 높은 자리수부터 메모리에 저장하는 방식입니다. 리틀 엔디안은 x86 아키텍처에서 사용되며, 빅 엔디안은 네트워크에서 사용됩니다. 
##### 프로세스와 스레드
프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이며, 스레드는 프로세스 내에서 실행되는 흐름의 단위입니다. 프로세스는 각각 독립된 메모리 영역을 가지며, 스레드는 프로세스 내의 메모리 영역을 공유합니다. 
##### Context switching에 대해 설명하시오.
CPU가 다른 프로세스나 스레드로 전환하는 과정을 말합니다. Context switching은 CPU의 현재 상태 정보를 저장하고 다음 상태 정보를 복원하는 과정으로, 오버헤드가 발생하며, 이를 줄이기 위해 멀티 코어를 사용하거나 스레드 풀을 사용합니다.
##### Mutex와 Semaphore란 무엇인가?
둘 다 여려 프로세스나 스레드가 공유 자원을 한번에 접근하는 것을 막기 위해 사용됩니다. Mutex는 락을 획득한 스레드만이 접근 가능하며 unlock을 하지 않으면 다른 스레드가 접근하지 못합니다. Semaphore는 최대 허용치 만큼만 접근이 가능하며, 허용치를 초과하면 대기하게 됩니다.
##### Dead lock에 대해 설명하시오.
두 개 이상의 프로세스나 스레드가 서로 상대방의 작업이 끝나기만을 기다리며, 무한 대기 상태에 빠지는 현상을 말합니다. 데드락을 해결하기 위해 다음과 같은 방법을 사용합니다.
##### Memory fragmentation에 대해 설명하시오.
메모리 단편화는 메모리 공간이 연속적이지 않아 발생하는 현상을 말합니다. 외부 단편화는 메모리 공간이 충분하지만 연속적이지 않아 사용할 수 없는 상태를 말하며, 내부 단편화는 프로세스가 필요한 양보다 더 큰 메모리가 할당되어 메모리가 낭비되는 현상을 말합니다. 단편화를 해결하기 위한 방법으로는 다음과 같습니다.
- 페이징 기법 : 메모리를 페이지 고정된 단위로 나누어 페이지 테이블을 이용하여 관리하는 방식.
- 세그멘테이션 기법 : 메모리를 가번젹인 크기로 나누어 사용합니다. 세그멘트 테이블을 이용하여 관리하는 방식.
- 메모리 풀 : 필요한 메모리 공간을 미리 할당해두고 사용하고 반납하는 방식입니다.


