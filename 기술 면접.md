##### 가상 함수 테이블과 virtual에 대해 설명하시오.
`virtual` 키워드는 C++에서 다형성을 구현하기 위한 도구로, 부모 클래스의 포인터나 참조를 사용해 자식 클래스의 동작을 런타임에 호출할 수 있도록 해줍니다.

가상 함수가 포함된 클래스는 가상 함수 테이블(vtable)이라는 구조를 생성합니다. vtable은 해당 클래스의 가상 함수들의 주소를 저장한 테이블입니다. 각 객체는 해당 클래스의 vtable을 가리키는 포인터(vptr)를 유지합니다. 가상 함수를 호출할 때는 vptr을 통해 vtable을 참조하고, 테이블에 저장된 함수 주소를 사용하여 런타임에 올바른 함수를 호출합니다. 단점으로는 일반 함수 호출보다 느리며, 메모리 오버헤드가 발생합니다.
##### 상속과 오버라이딩에 대해 설명하시오.
**상속이란** 기존 클래스(부모 클래스)의 **멤버 변수와 메서드**를 자식 클래스가 물려받아 사용할 수 있도록 하여 **코드 재사용성과 확장성**을 높이는 객체지향 프로그래밍의 중요한 특징 중 하나입니다. 상속은 **"is-a" 관계**를 나타내며, 예를 들어, "강아지는 동물이다"라는 관계에서 동물은 부모 클래스, 강아지는 자식 클래스가 됩니다. 부모 클래스의 멤버를 그대로 사용할 수도 있고, 자식 클래스에서 추가하거나 수정할 수도 있습니다.

**오버라이딩이란** 부모 클래스에서 `virtual` 키워드로 정의한 **가상 함수**를 자식 클래스가 재정의하여 사용하는 것을 말합니다. 이를 통해 부모와 자식 클래스가 동일한 함수 호출에 대해 서로 다른 동작을 구현할 수 있습니다.

**오버로딩**과 **오버라이딩**은 종종 혼동되지만, 다음과 같은 차이가 있습니다
**오버로딩**은 함수 이름은 같지만 매개변수의 개수나 타입이 다른 함수를 정의하여 **컴파일타임 다형성**을 구현합니다.
**오버라이딩**은 부모 클래스의 가상 함수를 자식 클래스에서 재정의하며, **런타임 다형성**을 구현합니다.
##### 스마트 포인터와 RAII에 대해 설명하시오.
RAII(Resource Acquisition Is Initialization)는 생성자와 소멸자를 활용한 디자인 패턴으로, 자원의 할당과 해제를 자동으로 처리하여 메모리 누수와 자원 누출을 방지하는 기법입니다. RAII는 C++의 강력한 기능 중 하나로, 객체의 생성자에서 자원을 할당하고, 소멸자에서 자원을 해제하여 자원 관리를 자동화합니다.

스마트 포인터란 RAII를 활용한 자원 관리 클래스로, GC가 없는 C++의 환경에서 동적 메모리 관리를 자동화하는데 사용됩니다. 대표적으로 `std::unique_ptr`, `std::shared_ptr`, `std::weak_ptr`가 있습니다.

- `std::unique_ptr`: 한 객체만 소유하며 소유권을 이전할 수 있습니다. 복사는 불가능하며, 소유권을 이전할 때는 `std::move()`를 사용합니다.
- `std::shared_ptr`: 여러 객체가 소유할 수 있으며 참조 횟수를 관리합니다. 참조 횟수가 0이 되면 자동으로 메모리를 해제합니다.
- `std::weak_ptr`: `std::shared_ptr`의 순환 참조 문제를 해결하기 위한 포인터로, 참조 카운터를 증가시키지 않고 참조만 가능합니다.
##### 스택과 힙 메모리의 차이점에 대해 설명하시오.
스택 메모리란 지역 변수, 함수 매개 변수, 함수 호출등의 정보를 저장하는 컴파일러 관리 메모리 영역입니다. 스택은 LIFO(Last In First Out) 방식으로 동작하며, 함수 호출 시 함수의 매개변수, 지역 변수, 복귀 주소 등이 스택 프레임에 저장됩니다. 스택 프레임은 함수 호출 시 생성되고 함수 종료 시 소멸됩니다. 힙 메모리는 동적 할당을 위한 메모리 영역으로, 프로그래머가 직접 메모리를 할당하고 해제해야 합니다. 힙 메모리는 메모리의 할당과 해제가 빈번하게 일어나는 경우에 사용되며, 메모리 누수와 해제되지 않은 메모리를 방지하기 위해 주의가 필요합니다. 스택 메모리는 힙 메모리보다 빠르지만 고정 크기이며, 정적 할당만 가능합니다. 힙 메모리는 크기가 상대적으로 크지만 느리며, 메모리 단편화가 발생할 수 있습니다.
##### 동적 할당이란 무엇이며, 왜 사용하는가?
동적 할당이란 프로그래머가 힙 메모리 영역에 메모리를 할당하는 것을 말합니다. `new` 키워드 및 `malloc()` 함수를 사용하여 메모리를 할당하고, `delete` 키워드 및 `free()` 함수를 사용하여 메모리를 해제합니다. 동적 할당은 프로그램 실행 중에 메모리를 동적으로 할당하고 해제할 수 있어, 메모리의 크기를 미리 알 수 없는 경우에 유용하게 사용됩니다.
##### Struct와 Class의 차이점은 무엇인가?
struct란 기본 접근 지정자가 public이며 class는 private입니다. 또한 상속 시 struct의 경우 public 상속이 기본이며, class는 private 상속이 기본입니다. 기본적인 기능은 차이가 없지만 보통 struct의 경우 데이터 구조를 표현하는데 사용하고, class는 데이터와 함수를 함께 사용하는 용도로 사용합니다.
##### 포인터와 배열의 차이점은 무엇인가?
배열 또한 연속된 데이터의 처음 시작 주소를 가르키는 포인터라고 할 수 있지만, 배열로써 선언된 변수는 포인터에서 가능한 증감, 대입 연산이 불가능합니다. 또한 배열의 경우 크기가 저장된 요소의 크기에 의해 결정되지만, 포인터의 경우 시스템에 따라 32비트 또는 64비트로 결정됩니다.
##### Malloc과 New의 차이점은 무엇인가?
`malloc()` 함수는 C언어에서 사용되는 메모리 할당 함수이고, `new` 키워드는 C++에서 사용되는 메모리 할당 연산자입니다. `malloc()` 함수는 메모리 할당 시 할당할 메모리의 크기를 바이트 단위로 지정해야 하며, 할당된 메모리는 초기화되지 않습니다. `new` 연산자는 클래스의 생성자를 호출하여 메모리를 초기화합니다. 또한 `new` 연산자는 `delete` 연산자를 사용하여 메모리를 해제해야 하지만, `malloc()` 함수는 `free()` 함수를 사용하여 메모리를 해제합니다.
##### Const에 대해 설명하시오.
`const`는 상수을 나타내는 키워드로, 데이터의 수정 가능성을 제한합니다. 이는 코드의 안정성과 가독성을 높이고, 의도치 않은 변경을 방지하는 데 유용합니다.

`const`와 포인터를 함께사용할때 위치에 따라 의미가 다르며 다음과 같이 사용됩니다.
- `int* const a = ptr;`: 포인터 a는 상수이므로 주소를 변경할 수 없습니다.
- `const int* a = ptr;`: 포인터 a가 가리키는 값은 변경할 수 없습니다.

`const`아 클래스 멤버 함수에서 사용할 경우, 멤버 변수의 값을 변경할 수 없습니다. 또한 반환값에 사용할 경우 반환값을 변경할 수 없습니다.



