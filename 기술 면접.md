##### 가상 함수 테이블과 virtual에 대해 설명하시오.
`virtual` 키워드는 C++에서 다형성을 구현하기 위한 도구로, 부모 클래스의 포인터나 참조를 사용해 자식 클래스의 동작을 런타임에 호출할 수 있도록 해줍니다.

가상 함수가 포함된 클래스는 가상 함수 테이블(vtable)이라는 구조를 생성합니다. vtable은 해당 클래스의 가상 함수들의 주소를 저장한 테이블입니다. 각 객체는 해당 클래스의 vtable을 가리키는 포인터(vptr)를 유지합니다. 가상 함수를 호출할 때는 vptr을 통해 vtable을 참조하고, 테이블에 저장된 함수 주소를 사용하여 런타임에 올바른 함수를 호출합니다. 단점으로는 일반 함수 호출보다 느리며, 메모리 오버헤드가 발생합니다.
##### 상속과 오버라이딩에 대해 설명하시오.
**상속이란** 기존 클래스(부모 클래스)의 **멤버 변수와 메서드**를 자식 클래스가 물려받아 사용할 수 있도록 하여 **코드 재사용성과 확장성**을 높이는 객체지향 프로그래밍의 중요한 특징 중 하나입니다. 상속은 **"is-a" 관계**를 나타내며, 예를 들어, "강아지는 동물이다"라는 관계에서 동물은 부모 클래스, 강아지는 자식 클래스가 됩니다. 부모 클래스의 멤버를 그대로 사용할 수도 있고, 자식 클래스에서 추가하거나 수정할 수도 있습니다.

**오버라이딩이란** 부모 클래스에서 `virtual` 키워드로 정의한 **가상 함수**를 자식 클래스가 재정의하여 사용하는 것을 말합니다. 이를 통해 부모와 자식 클래스가 동일한 함수 호출에 대해 서로 다른 동작을 구현할 수 있습니다.

**오버로딩**과 **오버라이딩**은 종종 혼동되지만, 다음과 같은 차이가 있습니다
**오버로딩**은 함수 이름은 같지만 매개변수의 개수나 타입이 다른 함수를 정의하여 **컴파일타임 다형성**을 구현합니다.
**오버라이딩**은 부모 클래스의 가상 함수를 자식 클래스에서 재정의하며, **런타임 다형성**을 구현합니다.
##### 스마트 포인터와 RAII에 대해 설명하시오.
RAII(Resource Acquisition Is Initialization)는 생성자와 소멸자를 활용한 디자인 패턴으로, 자원의 할당과 해제를 자동으로 처리하여 메모리 누수와 자원 누출을 방지하는 기법입니다. RAII는 C++의 강력한 기능 중 하나로, 객체의 생성자에서 자원을 할당하고, 소멸자에서 자원을 해제하여 자원 관리를 자동화합니다.

스마트 포인터란 RAII를 활용한 자원 관리 클래스로, GC가 없는 C++의 환경에서 동적 메모리 관리를 자동화하는데 사용됩니다. 대표적으로 `std::unique_ptr`, `std::shared_ptr`, `std::weak_ptr`가 있습니다.

- `std::unique_ptr`: 한 객체만 소유하며 소유권을 이전할 수 있습니다. 복사는 불가능하며, 소유권을 이전할 때는 `std::move()`를 사용합니다.
- `std::shared_ptr`: 여러 객체가 소유할 수 있으며 참조 횟수를 관리합니다. 참조 횟수가 0이 되면 자동으로 메모리를 해제합니다.
- `std::weak_ptr`: `std::shared_ptr`의 순환 참조 문제를 해결하기 위한 포인터로, 참조 카운터를 증가시키지 않고 참조만 가능합니다.
##### 스택과 힙 메모리의 차이점에 대해 설명하시오.
스택 메모리란 지역 변수, 함수 매개 변수, 함수 호출등의 정보를 저장하는 메모리 영역입니다. 스택은 LIFO(Last In First Out) 방식으로 동작하며, 함수 호출 시 함수의 매개변수, 지역 변수, 복귀 주소 등이 스택 프레임에 저장됩니다. 스택 프레임은 함수 호출 시 생성되고 함수 종료 시 소멸됩니다. 힙 메모리는 동적 할당을 위한 메모리 영역으로, 프로그래머가 직접 메모리를 할당하고 해제해야 합니다. 힙 메모리는 메모리의 할당과 해제가 빈번하게 일어나는 경우에 사용되며, 메모리 누수와 해제되지 않은 메모리를 방지하기 위해 주의가 필요합니다. 스택 메모리는 힙 메모리보다 빠르지만 고정 크기이며, 정적 할당만 가능합니다. 힙 메모리는 크기가 크지만 느리며, 메모리 단편화가 발생할 수 있습니다.







